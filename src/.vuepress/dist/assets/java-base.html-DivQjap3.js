import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as s,f as t}from"./app-B6LchBrR.js";const e={},p=t(`<h2 id="基础" tabindex="-1"><a class="header-anchor" href="#基础"><span>基础</span></a></h2><h3 id="java的移位运算符" tabindex="-1"><a class="header-anchor" href="#java的移位运算符"><span>java的移位运算符</span></a></h3><p>一共有三种</p><table><thead><tr><th>位移符号</th><th>作用</th></tr></thead><tbody><tr><td>左移(&lt;&lt;)</td><td>左移运算符，向左移若干位，高位丢弃，低位补零。x &lt;&lt; 1,相当于 x 乘以 2(不溢出的情况下)。</td></tr><tr><td>带符号右移(&gt;&gt;)</td><td>带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。x &gt;&gt; 1,相当于 x 除以 2。</td></tr><tr><td>无符号右移(&gt;&gt;&gt;)</td><td>无符号右移，忽略符号位，空位都以 0 补齐。</td></tr></tbody></table><blockquote><p>Java 只支持 int 和 long 的位移，浮点型数据不支持位移，其他的例如 short、byte、char 等类型进行位移前，也是先将它的类型转成 int 型再进行位移。</p></blockquote><p>位移示例：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token punctuation">(</span><span class="token number">6</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">)</span>
<span class="token number">0110</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">1100</span> <span class="token operator">=</span> <span class="token number">12</span>
<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">6</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">12</span><span class="token punctuation">)</span> 
<span class="token number">11111111111111111111111111111010</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">11111111111111111111111111110100</span>

<span class="token punctuation">(</span><span class="token number">6</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span>  
<span class="token number">0110</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">0011</span> <span class="token operator">=</span> <span class="token number">3</span>
<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">6</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span>  
<span class="token number">11111111111111111111111111111010</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token function">11111111111111111111111111111101</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span>


<span class="token punctuation">(</span><span class="token number">6</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span> 
<span class="token number">0110</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">0011</span> <span class="token operator">=</span> <span class="token number">3</span>
<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">6</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">2147483645</span><span class="token punctuation">)</span> 
<span class="token number">11111111111111111111111111111010</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token function">01111111111111111111111111111101</span><span class="token punctuation">(</span><span class="token number">2147483645</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>位移总结：</p><blockquote><p>&lt;&lt; &gt;&gt; 是有符号位移，所以最高位是啥还是啥，位移完正数还是正数，负数还是负数，&gt;&gt;&gt; 是无符号位移，最高位补0，如果是正数就是正常的位移，如果是负数，位移完变成了正数，注意没有 &lt;&lt;&lt;。</p></blockquote><h3 id="包装类型的缓冲机制" tabindex="-1"><a class="header-anchor" href="#包装类型的缓冲机制"><span>包装类型的缓冲机制</span></a></h3><p>Byte、Short、Integer、Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据<br> Character 创建了数值在 [0,127] 范围的缓存数据<br> Boolean 直接返回 True or False</p><blockquote><p>注意，Float、Double 并没有缓存机制。 注意 缓存机制可能导致 == 判断两个值不相等，所以包装类型比较还是用 equals 吧</p></blockquote><h3 id="自动装箱和拆箱" tabindex="-1"><a class="header-anchor" href="#自动装箱和拆箱"><span>自动装箱和拆箱</span></a></h3><p>其实代码编译后自动调用了 valueOf() 方法进行装箱，调用 xxValue() 方法进行拆箱。</p><h3 id="浮点数精度丢失问题" tabindex="-1"><a class="header-anchor" href="#浮点数精度丢失问题"><span>浮点数精度丢失问题</span></a></h3><p>计算机存储数据都是二进制的，而计算机位数是有限的，如果十进制转二进制发生循环就无法精准表达，例如 0.2 在转成二进制存储的时候，就会发生循环，无法使用二进制精准表达，就会出现精度丢失的问题。</p><blockquote><p>建议使用 BigDecimal 或者使用 long 来表达精度数据，new BigDecimal(&quot;0.2&quot;), 或者 200，表达 0.2。<br> 如果仅仅比较两个值是否相等，建议使用 compareTo 因为 compareTo 仅仅比较两个数值是否相等，例如 1.0 = 1, 如果用 equals 还会比较精度 1.0 != 1;</p></blockquote><h3 id="biginteger" tabindex="-1"><a class="header-anchor" href="#biginteger"><span>BigInteger</span></a></h3><p>用来表示大于 Long.MAX_VALUE 的值。</p><h3 id="java成员变量和局部变量" tabindex="-1"><a class="header-anchor" href="#java成员变量和局部变量"><span>Java成员变量和局部变量</span></a></h3><table><thead><tr><th>比较</th><th>成员变量</th><th>局部变量</th></tr></thead><tbody><tr><td>位置</td><td>类</td><td>方法</td></tr><tr><td>归属</td><td>对象</td><td>方法</td></tr><tr><td>存储</td><td>实例</td><td>栈空间</td></tr><tr><td>生存时间</td><td>实例创建-实例回收</td><td>方法调用-方法调用结束</td></tr><tr><td>默认值</td><td>自动赋默认值，对象=null, 基础类型=0</td><td>不会自动赋值</td></tr></tbody></table><h3 id="面向对象的三大特征" tabindex="-1"><a class="header-anchor" href="#面向对象的三大特征"><span>面向对象的三大特征</span></a></h3><p>封装，继承，多态。</p><h3 id="接口和抽象类" tabindex="-1"><a class="header-anchor" href="#接口和抽象类"><span>接口和抽象类</span></a></h3><p>根本的区别，接口是自顶而下的思想，抽象类是自底而上的设计。</p><h3 id="object" tabindex="-1"><a class="header-anchor" href="#object"><span>Object</span></a></h3><p>它是所有类的父类。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// native 获得当前类的引用对象</span>
getClass
<span class="token comment">// native hash 码</span>
hashCode
<span class="token comment">// 比较是否相等</span>
equals
<span class="token comment">// native 创建并返回当前对象的 copy</span>
clone
<span class="token comment">// 返回实例的哈希码的16进制字符串</span>
toString
<span class="token comment">// native 唤醒一个在此对象监视器上等待的线程，如果有多个线程在等待只会唤醒任意一个。</span>
notify
<span class="token comment">// native 唤醒所有在此对象监视器上等待的线程。</span>
notifyAll
<span class="token comment">// 暂停线程的执行。</span>
<span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">)</span>
<span class="token comment">// 同上</span>
<span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token keyword">int</span> nanos<span class="token punctuation">)</span>
<span class="token comment">// 同上，无超时时间，一直等待。</span>
<span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 被垃圾回收时触发。</span>
finalize
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="string-stringbuffer-stringbuilder-的区别" tabindex="-1"><a class="header-anchor" href="#string-stringbuffer-stringbuilder-的区别"><span>String, StringBuffer, StringBuilder 的区别</span></a></h3><p>String 是不可变的，内部使用 char[] 存储，jdk9 后优化成了 byte[] 存储，这个数组使用了 private final 进行修饰，也没有提供内部方法可以对它进行修改。<br> 例如语法糖的 a + b，其实就是创建了一个新的 StringBuilder 对象，拼接后生成了新的 String对象。</p><p>StringBuffer<br> 是安全的，它和 StringBuilder 都集成自 AbstactStringBuilder，它是基于模版方法模式，只不过StringBuilder 的所有方法都使用 Synchronied 进行了装饰，所以它是线程安全的。</p><p>StringBuilder<br> 和 StringBuffer 差不多，只不过方法没有加锁，如果是方法内String拼接，使用 StringBuilder 即可。</p><h3 id="字符串常量池" tabindex="-1"><a class="header-anchor" href="#字符串常量池"><span>字符串常量池</span></a></h3><p>字符串常量池在堆中，是JVM为了提高String对象效率提供的一片区域，主要是为了避免字符串的重复创建，字符串常量池放入堆中也是为了提供垃圾回收效率。</p><h3 id="string-intern" tabindex="-1"><a class="header-anchor" href="#string-intern"><span>String#intern</span></a></h3><p>一个 native 方法，作用是将指定的字符串对象的引用保存在字符串常量池中。<br> 1，如果字符串常量池中保存了对应的字符串对象的引用，直接返回该引用。<br> 2，如果字符串常量池中没有保存对应的字符串对象的引用，那就在字符串常量池中创建一个指向该字符串对象的引用并返回。<br> 3，例如：<br> String s1 = &quot;java&quot;, String s2 = new String(&quot;java&quot;),<br> String s3 = s1.intern(), String s4 = s2.intern();<br> 最终 s3， s4 得到的都是 s1 的对象引用。</p>`,36),l=[p];function r(o,i){return a(),s("div",null,l)}const u=n(e,[["render",r],["__file","java-base.html.vue"]]),b=JSON.parse('{"path":"/blog/java/java-base.html","title":"Java基础","lang":"zh-CN","frontmatter":{"title":"Java基础","category":["Java"],"order":1,"tag":["Java基础"],"description":"基础 java的移位运算符 一共有三种 Java 只支持 int 和 long 的位移，浮点型数据不支持位移，其他的例如 short、byte、char 等类型进行位移前，也是先将它的类型转成 int 型再进行位移。 位移示例： 位移总结： << >> 是有符号位移，所以最高位是啥还是啥，位移完正数还是正数，负数还是负数，>>> 是无符号位移，最高位补...","head":[["meta",{"property":"og:url","content":"https://opentp.cn/blog/java/java-base.html"}],["meta",{"property":"og:site_name","content":"opentp"}],["meta",{"property":"og:title","content":"Java基础"}],["meta",{"property":"og:description","content":"基础 java的移位运算符 一共有三种 Java 只支持 int 和 long 的位移，浮点型数据不支持位移，其他的例如 short、byte、char 等类型进行位移前，也是先将它的类型转成 int 型再进行位移。 位移示例： 位移总结： << >> 是有符号位移，所以最高位是啥还是啥，位移完正数还是正数，负数还是负数，>>> 是无符号位移，最高位补..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-07T12:27:03.000Z"}],["meta",{"property":"article:author","content":"zhanggong"}],["meta",{"property":"article:tag","content":"Java基础"}],["meta",{"property":"article:modified_time","content":"2024-04-07T12:27:03.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java基础\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-07T12:27:03.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"zhanggong\\",\\"url\\":\\"opentp.cn\\"}]}"]]},"headers":[{"level":2,"title":"基础","slug":"基础","link":"#基础","children":[{"level":3,"title":"java的移位运算符","slug":"java的移位运算符","link":"#java的移位运算符","children":[]},{"level":3,"title":"包装类型的缓冲机制","slug":"包装类型的缓冲机制","link":"#包装类型的缓冲机制","children":[]},{"level":3,"title":"自动装箱和拆箱","slug":"自动装箱和拆箱","link":"#自动装箱和拆箱","children":[]},{"level":3,"title":"浮点数精度丢失问题","slug":"浮点数精度丢失问题","link":"#浮点数精度丢失问题","children":[]},{"level":3,"title":"BigInteger","slug":"biginteger","link":"#biginteger","children":[]},{"level":3,"title":"Java成员变量和局部变量","slug":"java成员变量和局部变量","link":"#java成员变量和局部变量","children":[]},{"level":3,"title":"面向对象的三大特征","slug":"面向对象的三大特征","link":"#面向对象的三大特征","children":[]},{"level":3,"title":"接口和抽象类","slug":"接口和抽象类","link":"#接口和抽象类","children":[]},{"level":3,"title":"Object","slug":"object","link":"#object","children":[]},{"level":3,"title":"String, StringBuffer, StringBuilder 的区别","slug":"string-stringbuffer-stringbuilder-的区别","link":"#string-stringbuffer-stringbuilder-的区别","children":[]},{"level":3,"title":"字符串常量池","slug":"字符串常量池","link":"#字符串常量池","children":[]},{"level":3,"title":"String#intern","slug":"string-intern","link":"#string-intern","children":[]}]}],"git":{"createdTime":1712492823000,"updatedTime":1712492823000,"contributors":[{"name":"zhanggong","email":"zhanggong@58.com","commits":1}]},"readingTime":{"minutes":4.38,"words":1315},"filePathRelative":"blog/java/java-base.md","localizedDate":"2024年4月7日","autoDesc":true}');export{u as comp,b as data};
