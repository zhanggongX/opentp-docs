---
title: Java基础
category:
  - Java
order: 1
tag:
  - Java基础
---


## 基础
### java的移位运算符
一共有三种  
|位移符号|作用|
|----|----|
| 左移(<<) | 左移运算符，向左移若干位，高位丢弃，低位补零。x << 1,相当于 x 乘以 2(不溢出的情况下)。 |
| 带符号右移(>>) |带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。x >> 1,相当于 x 除以 2。|
| 无符号右移(>>>) |无符号右移，忽略符号位，空位都以 0 补齐。 |
> Java 只支持 int 和 long 的位移，浮点型数据不支持位移，其他的例如 short、byte、char 等类型进行位移前，也是先将它的类型转成 int 型再进行位移。  

位移示例：
```java
(6 << 1 = 12)
0110 << 1 = 1100 = 12
(-6 << 1 = -12) 
11111111111111111111111111111010 << 1 = 11111111111111111111111111110100

(6 >> 1 = 3)  
0110 >> 1 = 0011 = 3
(-6 >> 1 = -3)  
11111111111111111111111111111010 >> 1 = 11111111111111111111111111111101(-3)


(6 >>> 1 = 3) 
0110 >>> 1 = 0011 = 3
(-6 >>> 1 = 2147483645) 
11111111111111111111111111111010 >>> 1 = 01111111111111111111111111111101(2147483645)
```
位移总结：
> << >> 是有符号位移，所以最高位是啥还是啥，位移完正数还是正数，负数还是负数，>>> 是无符号位移，最高位补0，如果是正数就是正常的位移，如果是负数，位移完变成了正数，注意没有 <<<。

### 包装类型的缓冲机制
Byte、Short、Integer、Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据    
Character 创建了数值在 [0,127] 范围的缓存数据  
Boolean 直接返回 True or False
> 注意，Float、Double 并没有缓存机制。
> 注意 缓存机制可能导致 == 判断两个值不相等，所以包装类型比较还是用 equals 吧

### 自动装箱和拆箱
其实代码编译后自动调用了 valueOf() 方法进行装箱，调用 xxValue() 方法进行拆箱。

### 浮点数精度丢失问题
计算机存储数据都是二进制的，而计算机位数是有限的，如果十进制转二进制发生循环就无法精准表达，例如 0.2 在转成二进制存储的时候，就会发生循环，无法使用二进制精准表达，就会出现精度丢失的问题。
> 建议使用 BigDecimal 或者使用 long 来表达精度数据，new BigDecimal("0.2"), 或者 200，表达 0.2。  
> 如果仅仅比较两个值是否相等，建议使用 compareTo 因为 compareTo 仅仅比较两个数值是否相等，例如 1.0 = 1, 如果用 equals 还会比较精度 1.0 != 1;

### BigInteger 
用来表示大于 Long.MAX_VALUE 的值。

### Java成员变量和局部变量

| 比较 | 成员变量 | 局部变量 |
|----|----|----|
| 位置| 类 | 方法 |
| 归属| 对象 | 方法 |
| 存储| 实例| 栈空间 |
| 生存时间| 实例创建-实例回收 | 方法调用-方法调用结束 |
| 默认值| 自动赋默认值，对象=null, 基础类型=0 | 不会自动赋值 |

### 面向对象的三大特征
封装，继承，多态。

### 接口和抽象类
根本的区别，接口是自顶而下的思想，抽象类是自底而上的设计。

### Object
它是所有类的父类。
```java
// native 获得当前类的引用对象
getClass
// native hash 码
hashCode
// 比较是否相等
equals
// native 创建并返回当前对象的 copy
clone
// 返回实例的哈希码的16进制字符串
toString
// native 唤醒一个在此对象监视器上等待的线程，如果有多个线程在等待只会唤醒任意一个。
notify
// native 唤醒所有在此对象监视器上等待的线程。
notifyAll
// 暂停线程的执行。
wait(long timeout)
// 同上
wait(long timeout, int nanos)
// 同上，无超时时间，一直等待。
wait()
// 被垃圾回收时触发。
finalize
```

### String, StringBuffer, StringBuilder 的区别
String 
是不可变的，内部使用 char[] 存储，jdk9 后优化成了 byte[] 存储，这个数组使用了 private final 进行修饰，也没有提供内部方法可以对它进行修改。  
例如语法糖的 a + b，其实就是创建了一个新的 StringBuilder 对象，拼接后生成了新的 String对象。

StringBuffer   
是安全的，它和 StringBuilder 都集成自 AbstactStringBuilder，它是基于模版方法模式，只不过StringBuilder 的所有方法都使用 Synchronied 进行了装饰，所以它是线程安全的。  

StringBuilder  
和 StringBuffer 差不多，只不过方法没有加锁，如果是方法内String拼接，使用 StringBuilder 即可。

### 字符串常量池
字符串常量池在堆中，是JVM为了提高String对象效率提供的一片区域，主要是为了避免字符串的重复创建，字符串常量池放入堆中也是为了提供垃圾回收效率。

### String#intern
一个 native 方法，作用是将指定的字符串对象的引用保存在字符串常量池中。  
1，如果字符串常量池中保存了对应的字符串对象的引用，直接返回该引用。  
2，如果字符串常量池中没有保存对应的字符串对象的引用，那就在字符串常量池中创建一个指向该字符串对象的引用并返回。   
3，例如：  
String s1 = "java", String s2 = new String("java"),   
String s3 = s1.intern(), String s4 = s2.intern();   
最终 s3， s4 得到的都是 s1 的对象引用。
