---
title: ZGC垃圾回收器
category:
  - Java
order: 101
tag:
  - Java基础
  - JDK
  - ZGC
---

## ZGC 介绍
ZGC（Z Garbage Collector）是 Java 虚拟机（JVM）的一种垃圾收集器，专为高吞吐量和低延迟而设计。在 JDK 11 中首次引入，并在后续版本中不断优化和增强。

## ZGC 的主要特性

### 1. 低延迟
ZGC 的设计目标之一是将垃圾收集（GC）的停顿时间控制在 10 毫秒以内。无论堆的大小是几百 MB 还是几 TB，ZGC 都能保持短暂且可预测的停顿时间。

### 2. 大堆支持
ZGC 可以高效地管理高达数 TB 的堆内存，这使得它非常适合大数据处理、内存密集型应用和高性能计算等场景。

### 3. 并发性
ZGC 是一个并发垃圾收集器，大多数垃圾收集工作都与应用程序线程并发进行。它的并发操作包括标记、压缩和类卸载等。

### 4. 可伸缩性
ZGC 具有良好的伸缩性，能够利用多核处理器的优势，适合在多核服务器上运行。

### 5. 零停顿压缩
ZGC 使用了并发堆压缩技术，允许在不暂停应用程序线程的情况下进行堆内存压缩，从而减少了内存碎片。

### 6. 高效的内存管理
ZGC 使用指针压缩（Pointer Compression）技术和多映射内存来有效地管理和访问大内存空间。

## 原理

### 1. 并发标记
ZGC 的并发标记阶段采用了标记-清除（Mark-Sweep）算法。它在不暂停应用程序线程的情况下标记所有活动对象。标记阶段分为初始标记（Initial Marking）、并发标记（Concurrent Marking）和最终标记（Final Marking）。

- 初始标记：快速标记从根对象直接引用的对象。
- 并发标记：并发扫描整个堆，标记所有活动对象。
- 最终标记：完成所有未完成的标记任务，确保没有漏掉任何活动对象。

### 2. 并发重定位
并发重定位（Concurrent Relocation）是 ZGC 的一个重要特性。它允许在不停止应用程序的情况下移动对象，从而减少内存碎片。

- 对象分配：ZGC 使用区域（Region）来管理堆内存，每个区域负责存储一部分对象。
- 对象移动：当需要压缩堆时，ZGC 将对象移动到新的内存位置，同时更新引用。

### 3. 并发清理
并发清理（Concurrent Cleanup）阶段用于回收不可达的对象。ZGC 采用标记-清除算法来清理内存，确保没有活动对象被误删除。

- 垃圾回收：ZGC 在不暂停应用程序的情况下回收无用的内存区域。

### 4. 并发堆压缩
堆压缩（Heap Compaction）是一种减少内存碎片的方法。ZGC 在不暂停应用程序的情况下对堆进行压缩，确保内存连续可用。

- 减少碎片：通过移动对象和合并空闲区域，ZGC 减少了内存碎片。

## 主要增强和改进（JDK 21）

### 1. 并发类卸载
在 JDK 21 中，ZGC 引入了并发类卸载功能，使得类卸载可以与应用程序线程并发进行，减少了类卸载对应用程序的影响。

### 2. 标记阶段优化
ZGC 优化了并发标记阶段的性能，使得标记过程更加高效，减少了对应用程序的干扰。

### 3. 内存使用效率提升
ZGC 改进了内存管理策略，提高了内存的使用效率，减少了内存碎片。

### 4. 并发堆压缩
在 JDK 21 中，ZGC 增加了并发堆压缩功能，进一步减少了内存碎片和提升了性能。

### 5. 支持更高并发度
ZGC 增强了对高并发任务的支持，能够在更多的 CPU 核心上并行执行垃圾收集任务，提高了性能。

### 6. 改进的调试和监控工具
JDK 21 中，ZGC 改进了调试和监控工具，提供了更直观的垃圾收集监控和调试功能。

## 配置和使用

### 启用 ZGC

可以通过命令行选项启用 ZGC：

```bash
java -XX:+UseZGC -Xmx16G -jar myapp.jar
```

### 常用配置选项

- `-XX:+UseZGC`：启用 ZGC。
- `-Xms` 和 `-Xmx`：设置最小和最大堆大小。
- `-XX:ZCollectionInterval=N`：设置两次垃圾收集之间的最小间隔，单位为秒。
- `-XX:ZFragmentationLimit=F`：设置堆碎片率的阈值，超过此值将触发堆压缩。
- `-XX:ZMarkingThreads=N`：设置标记阶段的线程数量。

## 性能对比

以下是 ZGC 与其他垃圾收集器的性能对比示例：

| 特性                  | G1 GC       | CMS         | ZGC         |
|-----------------------|-------------|-------------|-------------|
| 平均停顿时间          | 100 ms      | 200 ms      | 10 ms       |
| 最大堆支持            | 4 TB        | 1 TB        | 16 TB+      |
| 并发执行              | 部分        | 部分        | 全部        |
| 内存碎片率            | 10%         | 15%         | 2%          |
| 堆压缩                | 支持        | 不支持      | 支持        |

JDK 21 中 ZGC 的改进对性能的影响。以下是一个示例对比结果：

| 特性                  | JDK 17 中的 ZGC | JDK 21 中的 ZGC |
|-----------------------|----------------|----------------|
| 类卸载时间            | 50 ms          | 5 ms           |
| 堆压缩效率            | 70%            | 95%            |
| 最大支持的并发任务数量 | 10,000         | 100,000        |
| 停顿时间              | 15 ms          | 10 ms          |
| 内存碎片率            | 10%            | 2%             |

## 应用场景

### 1. 大数据处理
ZGC 能够高效地管理大规模堆内存，适合处理大量数据的应用，如大数据分析和数据流处理。

### 2. 实时系统
ZGC 的低停顿时间非常适合实时系统，如交易系统、游戏服务器和实时监控系统。

### 3. 云计算和分布式系统
ZGC 的高伸缩性和低延迟特性使其非常适合在云计算和分布式系统中使用。

### 4. 高性能应用
需要高并发处理和大规模内存管理的应用，如高性能计算和企业级应用。

## 未来发展

ZGC 作为一个前沿的垃圾收集器，不断在性能、稳定性和功能上进行优化。未来的发展方向可能包括：

- 进一步降低延迟：继续优化算法，进一步减少垃圾收集的停顿时间。
- 提高并发能力：增强对多核处理器的支持，提高并发执行效率。
- 扩展支持的硬件平台：增加对更多硬件平台的支持，提高跨平台性能。

通过这些不断的改进和优化，ZGC 将继续为 Java 应用程序提供更高效、低延迟的垃圾收集解决方案。

## 总结

ZGC 在 JDK 21 中得到了显著的增强和改进，进一步巩固了其作为低延迟、高性能垃圾收集器的地位。它的低停顿时间、大规模堆支持、并发性和高效内存管理使得它非常适合需要处理大量数据和高并发任务的应用。无论是在大数据处理、实时系统、云计算还是高性能应用中，ZGC 都提供了强大的垃圾收集能力，为 Java 应用程序的稳定性和性能保驾护航。