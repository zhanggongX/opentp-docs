---
title: ZGC垃圾回收器
category:
  - Java
order: 81
tag:
  - Java基础
  - JDK
  - ZGC
---

ZGC（Z Garbage Collector）是一个高度可伸缩的低延迟垃圾收集器，适用于内存使用大且对延迟敏感的应用。它的设计目标是使暂停时间保持在 10 毫秒以下，且随着堆大小增长，暂停时间几乎不变。ZGC 支持非常大的堆（高达数 TB），并能够在高并发情况下高效地进行垃圾收集。

### 7.1. 并发类卸载（Concurrent Class Unloading）

ZGC 在 JDK 21 中引入了并发类卸载功能，使得类卸载过程能够与应用线程并发进行。这意味着类卸载不再需要长时间的全局暂停，从而进一步降低了垃圾收集的停顿时间。

- 优势：减少了类卸载对应用程序性能的影响。
- 应用场景：对频繁加载和卸载类的应用程序，如动态 Web 应用和插件系统，非常有益。

### 7.2. 并发标记阶段优化（Concurrent Marking Phase Optimization）

在 JDK 21 中，ZGC 的并发标记阶段得到了优化，显著提高了垃圾收集器的性能。优化措施包括改进的标记算法和更高效的并发执行，使得标记阶段对应用程序的影响更小。

- 优势：标记阶段更快，减少了对应用线程的干扰。
- 应用场景：适用于需要大规模并发处理的应用程序，如大数据处理和流式计算。

### 7.3. 内存使用效率提升（Improved Memory Utilization）

ZGC 在 JDK 21 中改进了内存管理策略，提升了内存使用效率。新的内存管理策略能够更智能地回收和分配内存，从而减少内存碎片和内存使用峰值。

- 优势：更高效的内存使用，减少内存碎片和提升性能。
- 应用场景：对内存敏感的应用程序，如实时数据分析和高性能计算。

### 4. 提升的伸缩性（Improved Scalability）

ZGC 在 JDK 21 中增强了其伸缩性，能够更高效地处理超大规模的堆内存。这意味着应用程序可以使用更大的堆而不会导致垃圾收集器性能下降。

- 优势：支持更大规模的堆，适应高内存需求的应用。
- 应用场景：大规模数据处理、企业级应用和云计算环境。

### 5. 并发堆压缩（Concurrent Heap Compaction）

JDK 21 中的 ZGC 引入了并发堆压缩功能，允许垃圾收集器在不暂停应用程序的情况下对堆进行压缩。堆压缩有助于减少内存碎片，提高内存使用效率。

- 优势：减少内存碎片，提高内存使用效率。
- 应用场景：需要长时间运行且内存管理要求严格的应用。

### 6. 混合模式收集（Mixed-Mode Collection）

ZGC 在 JDK 21 中引入了混合模式收集，即同时进行年轻代和老年代的垃圾收集。这种方式使得垃圾收集器能够更高效地管理内存，减少了老年代的内存占用。

- 优势：提高了老年代的内存回收效率。
- 应用场景：需要频繁进行老年代内存管理的应用。

### 7. 支持更高并发度（Support for Higher Concurrency）

JDK 21 中的 ZGC 增强了对高并发任务的支持，能够在更多的 CPU 核心上并行执行垃圾收集任务，提高了垃圾收集器的吞吐量和性能。

- 优势：提升了并发处理能力，适应多核环境。
- 应用场景：高并发服务、并行计算和多核处理应用。

### 8. 改进的调试和监控工具（Improved Debugging and Monitoring Tools）

ZGC 在 JDK 21 中改进了调试和监控工具，使得开发者能够更容易地监控垃圾收集的运行情况，识别和解决性能问题。

- 优势：提供了更直观的垃圾收集监控和调试功能。
- 应用场景：需要精确性能监控和调试的应用。

### 9. 更好的互操作性（Improved Interoperability）

ZGC 在 JDK 21 中增强了与其他 Java 特性的互操作性，如与 Project Loom 的虚拟线程更好地集成。它支持在虚拟线程中高效地进行垃圾收集，提升了整体系统性能。

- 优势：与其他并发编程模型更好地集成。
- 应用场景：使用虚拟线程的并发应用。

## 使用示例

以下是一个简单的示例代码，展示了如何在 JDK 21 中启用 ZGC 及其配置：

### 启用 ZGC

在命令行中启用 ZGC：

```bash
java -XX:+UseZGC -Xmx16G -jar myapp.jar
```

### 配置 ZGC

在代码中配置 ZGC：

```java
public class ZGCExample {
    public static void main(String[] args) {
        System.out.println("ZGC is enabled");

        // 模拟大量内存分配
        for (int i = 0; i < 100_000; i++) {
            byte[] data = new byte[1_000_000];
        }

        System.out.println("Memory allocation completed");
    }
}
```

### 监控 ZGC

使用 JDK 提供的监控工具（如 JDK Mission Control）来监控 ZGC 的运行情况。

```bash
jmc
```

在 JDK Mission Control 中，可以查看 ZGC 的详细运行状态和性能指标。

## 性能对比

通过实际应用的性能测试，可以看到 JDK 21 中 ZGC 的改进对性能的影响。以下是一个示例对比结果：

| 特性                  | JDK 17 中的 ZGC | JDK 21 中的 ZGC |
|-----------------------|----------------|----------------|
| 类卸载时间            | 50 ms          | 5 ms           |
| 堆压缩效率            | 70%            | 95%            |
| 最大支持的并发任务数量 | 10,000         | 100,000        |
| 停顿时间              | 15 ms          | 10 ms          |
| 内存碎片率            | 10%            | 2%             |

## 总结

JDK 21 中的 ZGC 增强了并发处理能力、内存管理和垃圾收集效率，极大地提升了 Java 应用的性能和稳定性。无论是处理高并发任务、进行大规模数据处理，还是需要严格内存管理的应用，ZGC 都提供了强大且高效的支持。通过这些改进，开发者可以更加轻松地管理内存和优化性能，从而专注于业务逻辑的实现。