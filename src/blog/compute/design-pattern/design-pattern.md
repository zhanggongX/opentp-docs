---
title: 设计模式概述
category:
  - 计算机基础
order: 1
tag:
  - 计算机基础
  - 设计模式
---

## 设计模式
所谓的设计模式，其实就是对 封装、继承、多态、组合的灵活运用。  
实际使用过程中也不用特别纠结于某种设计模式，只要我们设计的程序足够可维护、可扩展、可复用和灵活性好，就是好的代码设计。

### 面向对象的一些开发规则
#### 单一职责原则(SRP)
就一个类而言，应该仅有一个引起它变化的原因，就是不同的功能不要往一个类里凑。
> 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。  
#### 开闭原则
是说软件实体(类、模块、函数等等)应该可以扩展，但是不可修改。  
任何系统都不要指望系统一开始时需求确定，就再也不会变化，这是不现实也不科学的想法，既然需求是一定会变化的，那么如何在面对需求的变化时，设计的软件可以相对容易修改，不至于新需求一来，就要把整个程序推倒重来。怎样的设计才能面对需求的改变却可以保持相对稳定，从而使得系统可以在第一个版本以后不断推出新的版本。这就是开闭原则来规范的事情。只要我们的软件设计的足够解偶，灵活，符合开闭原则，后续迭代就能很健康的迭代下去。
#### 依赖倒转原则
- 高层模块不应该依赖低层模块。两个都应该依赖抽象。 
- 抽象不应该依赖细节。细节应该依赖抽象。
> 说白了，就是要针对接口编程，不要对实现编程，例如我们的电脑，电脑的内存、cpu、硬盘都是根据主板的接口实现的，当电脑某一个模块坏了，比如内存坏了，更换内存而且是任何牌子的内存即可。这就是依赖倒转原则。

那什么叫高层模块不应该依赖底层模块，两个都应该依赖抽象呢？这个可以参考我们的业务程序和我们的数据库驱动，我们业务程序是高层模块，数据库驱动是底层模块，正常来说我们的程序要访问数据库是要依赖底层模块数据库驱动的，但是如果我们需要更改数据库的时候呢？就比较麻烦了，所以我们实际的开发中，他们都是依赖于抽象的，就像 JDK 提供了 SPI java.sql.driver。我们的程序只需要使用这个接口即可，我们使用不同的数据库，自然有不同的实现类，而我们的业务代码完全不 care 实现类具体是什么。
#### 里氏替换原则
一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。在软件里面，把父类都替换成它的子类，程序的行为没有变化，简单的说就是：子类型必须能够替换掉它们的父类型。  
由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展。不然还谈什么扩展开放，修改关闭呢。再回过头来看依赖倒转原则，高层模块不应该依赖低层模块，两个都应该依赖抽象，就更好理解了。
> 里氏替换原则是多态的基础？



### 类的表示方式 UML
#### 类的UML
UML 就是一个框，框内分三层，第一层是类名（如果是接口或者抽象类，用斜体），第二层是字段或者说属性，第三层是类的方法或者说行为。
|类名|
|-|
|+属性  -属性  #属性|
|+方法  -方法  #方法|
>+ 表示 public, - 表示 private, # 表示 protected
#### 关系的UML
类的关系有继承，实现接口，关联关系，聚合关系，组合关系，依赖关系。  
- 继承使用 **三角+实线** 表示，三角指向被继承的类。
- 实现接口用 **三角+虚线** 表示，三角指向被实现的接口。
- 类A内有个类B，这种叫关联关系，使用 **实线箭头** 表示，类A -> 类B。
- 雁群由大雁组成，这种叫聚合关系；使用 **空心菱形+实线箭头** 表示 classA 内有 ClassB[] 。
- 鸟由身体和翅膀组成，鸟和翅膀就是组合关系，使用实心的 **菱形+实线箭头** 表示。
- 鸟依赖氧气和水，这种就是依赖关系，使用 **虚线箭头** 表示。

## 设计模式分类
设计模式分为三大类，创建型，结构型，

### 创建型
- 工厂
- 模板工厂
- 抽象工厂
- 单例
- builder
- 原型

创建型设计模式最好理解，也没有什么难的地方，只是创建复杂的对象的时候供我们选择而已。  
1. 单例模式，使用场景单一，只需要保证多线程创建一个单例对象即可。  
2. 三大工厂主要是用来创建一个接口，多个实现，或者多个接口多个实现这种场景。
3. 建造者模式，主要用来构造复杂的对象，  
好处一：给非必选的的属性添加默认值，  
好处二：控制一些属性必填，  
好处三：build() 时候可以进行一些校验。  
4. 原型模式也很简单，适合默认构造方法比较复杂，那我们就可以构造出一个原型对象，然后每次克隆一个，直接使用或者对部分属性进行修改后使用，避开了耗时的构造方法。
> 注意：构造简单的对象，构造方法也没有很复杂的逻辑，原型模式对比直接 new 对象，并没有效率上的优势。

### 结构型


