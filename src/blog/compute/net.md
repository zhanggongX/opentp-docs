---
title: 计算机网络
category:
  - 计算机基础
order: 20
tag:
  - 计算机基础
  - 网络
---

## 网络模型
主要的网络模型包括：  
OSI（Open Systems Interconnection）七层模型  
TCP/IP（Transmission Control Protocol/Internet Protocol）四层模型。  

### OSI 模型
OSI 模型由国际标准化组织（ISO）提出，是一个七层网络模型，用于定义和规范网络通信的过程。每一层都有特定的功能，通过封装与解封装的方式向上或向下传递数据。

### OSI 模型图示

```
+----------------------+
| 应用层   (Application) |
+----------------------+
| 表示层   (Presentation)|
+----------------------+
| 会话层   (Session)    |
+----------------------+
| 传输层   (Transport)  |
+----------------------+
| 网络层   (Network)    |
+----------------------+
| 数据链路层 (Data Link) |
+----------------------+
| 物理层   (Physical)   |
+----------------------+
```

### OSI 模型的七层结构

1. 物理层（Physical Layer）  
定义了物理设备的标准，包括接口、电压、传输速度、信号调制等。主要负责数据的物理传输，如电信号或光信号。   
比如设备：网线、光纤、网卡等。   
主要协议有：以太网、RS-232 等。  

2. 数据链路层（Data Link Layer）    
提供介质访问控制（MAC）和链路管理，确保可靠的数据传输。处理数据帧的封装与传输，负责错误检测和纠正。  
比如设备：交换机、网桥。  
主要协议有：以太网协议、帧中继（Frame Relay）、PPP（点对点协议）。

3. 网络层（Network Layer）  
负责数据的路由和转发，提供逻辑地址的分配和管理，实现不同网络之间的数据通信。  
比如设备：路由器。   
主要协议有：IP、ICMP、ARP。

4. 传输层（Transport Layer）  
提供端到端的通信服务，负责数据的分段、重组、流量控制和错误处理。  
协议：TCP（Transmission Control Protocol）、UDP（User Datagram Protocol）。

5. 会话层（Session Layer）   
管理会话连接，负责建立、维护和终止通信会话，支持数据的同步和恢复。  
协议：PPTP（Point-to-Point Tunneling Protocol）、RPC（Remote Procedure Call）。

6. 表示层（Presentation Layer）  
处理数据的格式化、加密、解密和压缩，确保数据能够被接收方正确解释。
协议：SSL/TLS、JPEG、GIF、MPEG。

7. 应用层（Application Layer）
提供网络服务和接口给应用程序，包括文件传输、电子邮件、远程登录等。
协议：HTTP、FTP、SMTP、DNS。



### TCP/IP 模型

TCP/IP 模型是由美国国防部开发的四层模型，是现代互联网的基础。相比 OSI 模型，TCP/IP 模型更为简洁实用，强调实现而非理论。

### TCP/IP 模型图示

```
+---------------------+
| 应用层 (Application) |
+---------------------+
| 传输层 (Transport)  |
+---------------------+
| 网络层 (Internet)   |
+---------------------+
| 网络接口层 (Network Interface) |
+---------------------+
```

### TCP/IP 模型的四层结构

1. 网络接口层（Network Interface Layer）  
对应 OSI 的物理层和数据链路层，负责在特定物理网络上发送 IP 数据包。  
协议：以太网协议、Wi-Fi、Token Ring。

2. 网络层（Internet Layer）  
与 OSI 的网络层相似，负责路由和转发数据包。
协议：IP（Internet Protocol）、ICMP、ARP。

3. 传输层（Transport Layer）  
提供端到端的通信服务，类似于 OSI 模型的传输层。  
协议：TCP、UDP。  

4. 应用层（Application Layer）  
对应 OSI 模型的会话层、表示层和应用层，直接为应用程序提供服务。  
协议：HTTP、FTP、SMTP、DNS。

## OSI 与 TCP/IP 模型对比

- 层数：OSI 模型有七层，TCP/IP 模型有四层。
- 应用：OSI 是理论模型，主要用于教学和标准化；TCP/IP 是实际应用的网络模型。
- 灵活性：OSI 模型较为复杂，适合各种通信系统的描述；TCP/IP 模型较为灵活，简化了实现过程。

### 图示对比

```
OSI 模型                          TCP/IP 模型
+------------------+               +-----------------+
| 应用层 (Application)   | <-> | 应用层 (Application)|
+------------------+               +-----------------+
| 表示层 (Presentation) | <-> |                   |
+------------------+               +-----------------+
| 会话层 (Session)      | <-> |                   |
+------------------+               +-----------------+
| 传输层 (Transport)   | <-> | 传输层 (Transport) |
+------------------+               +-----------------+
| 网络层 (Network)     | <-> | 网络层 (Internet)  |
+------------------+               +-----------------+
| 数据链路层 (Data Link) | <-> | 网络接口层 (Network Interface)|
+------------------+               +-----------------+
| 物理层 (Physical)     | <-> |                   |
+------------------+               +-----------------+
```

## 通信过程

### 从 HTTP 到 MAC

1. HTTP 层（应用层）  
应用程序生成一个 HTTP 请求，例如浏览器访问一个网页。请求头部和数据被封装成 HTTP 报文。

   ```http
   GET /index.html HTTP/1.1
   Host: www.example.com
   ```

2. TCP 层（传输层）  
首先 HTTP 报文被封装成 TCP 数据段（Segment），如果数据过大，TCP 会将其分段， 然后给 HTTP 报文添加头部， TCP 头部包含源端口、目标端口、序列号等信息，最后通过三次握手建立与服务器的连接。

   ```text
   +--------------------------------------+
   | TCP 头部 | HTTP 数据                 |
   +--------------------------------------+
   ```

3. IP 层（网络层）    
首先，TCP 数据段被封装成 IP 数据包（Packet），然后添加 IP 头部，包含源 IP 地址、目标 IP 地址等信息。数据包通过路由器进行转发，选择最佳路径到达目标网络。  

   ```text
   +---------------------------------------------+
   | IP 头部 | TCP 数据段                        |
   +---------------------------------------------+
   ```

4. 网络接口层（MAC 层）  
首先，IP 数据包被封装成帧（Frame），帧的头部包含源 MAC 地址、目标 MAC 地址，尾部包含校验码。帧通过网络介质（如以太网、Wi-Fi）发送到物理网络。

   ```text
   +----------------------------------------------------+
   | MAC 头部 | IP 数据包                         | FCS |
   +----------------------------------------------------+
   ```



### 从 MAC 到 HTTP
从 MAC 到 HTTP 是从 HTTP 到 MAC 过程的逆过程。

### 总结
网络通信过程，从高层协议到底层协议，就是一直封包的过程，一直添加底层协议的数据包头。  
以 TCP 通信为例，假设我们有两个设备，
在 TCP 通信过程中，特别是在不同子网之间的通信，数据包会经过多次封装和解封装，涉及 IP 地址和 MAC 地址的不断变化。下面是详细的过程和变化情况：

## TCP 通信过程概述
假设有两个子网。
- 子网 1：192.168.1.0/24  
主机 A：192.168.1.2，MAC 地址：AA:AA:AA:AA:AA:AA  
路由器 R1：192.168.1.1，MAC 地址：R1:MAC:1

- 子网 2：192.168.2.0/24  
主机 B：192.168.2.2，MAC 地址：BB:BB:BB:BB:BB:BB  
路由器 R2：192.168.2.1，MAC 地址：R2:MAC:1  

### 数据包传输过程

1. 主机 A 向主机 B 发送数据
   - 主机 A 生成 TCP 数据：包括源 IP：192.168.1.2，目标 IP：192.168.2.2。
   - 主机 A 查询路由：发现目标 IP 不在同一子网，需要通过网关 R1 转发。

2. 主机 A 封装数据包
   - 生成 TCP 数据段：包括源端口、目标端口、序列号等。
   - 生成 IP 数据包：包括源 IP 地址（192.168.1.2），目标 IP 地址（192.168.2.2）。
   - 生成帧：主机 A 使用 ARP（地址解析协议）查询 R1 的 MAC 地址，将目标 MAC 地址设为 R1:MAC:1。
   > 目标 MAC 地址是路由器的地址。
   ```text
   +---------------------------+-------------------------------+-------------------------------+
   | MAC 头部 (AA:AA:AA:AA:AA:AA -> R1:MAC:1)                   | 数据内容                       |
   +---------------------------+-------------------------------+-------------------------------+
   | IP 头部 (192.168.1.2 -> 192.168.2.2)                       | TCP 数据段                     |
   +---------------------------+-------------------------------+-------------------------------+
   ```

3. 主机 A 发送数据到路由器 R1
   - 帧到达 R1：R1 接收到帧，根据 MAC 地址识别为自己的帧。
   - R1 解封装帧：去掉 MAC 头部，获得 IP 数据包。

4. 路由器 R1 转发数据包
   - R1 查询路由表：发现目标 IP 在 192.168.2.0/24 子网，需要通过 R2 转发。
   - R1 封装新的帧：将目标 MAC 地址设为 R2 的 MAC 地址（R2:MAC:1）。

   ```text
   +---------------------------+-------------------------------+-------------------------------+
   | MAC 头部 (R1:MAC:1 -> R2:MAC:1)                            | 数据内容                       |
   +---------------------------+-------------------------------+-------------------------------+
   | IP 头部 (192.168.1.2 -> 192.168.2.2)                       | TCP 数据段                     |
   +---------------------------+-------------------------------+-------------------------------+
   ```

5. 数据包在中间网络中传输
   - R1 发送到 R2：帧从 R1 到达 R2。
   - R2 接收并解封装帧：R2 解封装帧，检查 IP 数据包。

6. 路由器 R2 转发数据包
   - R2 查询路由表：发现目标 IP 地址属于 192.168.2.0/24 子网，下一跳为主机 B。
   - R2 封装新的帧：将目标 MAC 地址设为主机 B 的 MAC 地址（BB:BB:BB:BB:BB:BB）。

   ```text
   +---------------------------+-------------------------------+-------------------------------+
   | MAC 头部 (R2:MAC:1 -> BB:BB:BB:BB:BB:BB)                   | 数据内容                       |
   +---------------------------+-------------------------------+-------------------------------+
   | IP 头部 (192.168.1.2 -> 192.168.2.2)                       | TCP 数据段                     |
   +---------------------------+-------------------------------+-------------------------------+
   ```

7. 主机 B 接收数据
   - 帧到达主机 B：主机 B 接收到帧，根据 MAC 地址识别为自己的帧。
   - 主机 B 解封装帧：去掉 MAC 头部，检查 IP 数据包。
   - 解封装 IP 数据包：去掉 IP 头部，检查 TCP 数据段。
   - TCP 处理：主机 B 根据 TCP 头部信息处理数据，发送确认消息。

### 数据包的 IP 和 MAC 地址变化

| 阶段            | 源 IP 地址      | 目标 IP 地址     | 源 MAC 地址        | 目标 MAC 地址       |
| --------------- | --------------- | --------------- | ------------------ | ------------------- |
| 主机 A 发送     | 192.168.1.2     | 192.168.2.2     | AA:AA:AA:AA:AA:AA  | R1:MAC:1            |
| R1 转发到 R2    | 192.168.1.2     | 192.168.2.2     | R1:MAC:1           | R2:MAC:1            |
| R2 转发到主机 B | 192.168.1.2     | 192.168.2.2     | R2:MAC:1           | BB:BB:BB:BB:BB:BB   |
| 主机 B 接收     | 192.168.1.2     | 192.168.2.2     | BB:BB:BB:BB:BB:BB  | B 无需更改         |

> B 机器处理完请求返回，则是上述过程的逆过程。

### 总结

- MAC 地址变化：每一跳（如主机到路由器，路由器到路由器，路由器到主机），MAC 地址会变化为下一跳的目标 MAC 地址。
- IP 地址不变：源 IP 和目标 IP 在整个传输过程中保持不变，用于标识端到端的通信。

## TCP&UDP
传输控制协议（TCP，Transmission Control Protocol） 和 用户数据报协议（UDP，User Datagram Protocol）。

### TCP 和 UDP 的区别
1. 连接性：TCP 是面向连接的协议，在传输数据之前需要建立连接（三次握手），传输结束后需要断开连接（四次挥手）；UDP 是无连接的协议。
2. 可靠性：TCP 提供可靠的数据传输，通过确认机制（ACK）、超时重传、序列号等机制，确保数据包按顺序到达且无丢失；UDP 不保证数据的可靠性，发送的数据报文可能会丢失、重复或乱序到达，没有重传机制。
3. 数据传输方式：TCP 面向字节流传输，数据被看作是无边界的字节流；UDP 面向报文传输，每个报文是一个独立的数据包，应用程序接收到的报文是原封不动的。
4. 开销：TCP 因为需要建立连接、维护状态、传输数据时需要确认等操作，开销较大；UDP 无需建立连接，报文头较小，传输开销小，效率高。
5. 是否支持广播：TCP 只支持点对点；UDP，支持广播。

### TCP/UDP 使用选择
1. 什么时候用 TCP
- 需要可靠传输：如文件传输、电子邮件、远程登录等需要确保数据完整性和准确性的场景。
- 数据顺序重要：如HTTP请求、数据库操作等，需要数据按顺序到达。

2. 什么时候用 UDP
- 实时性要求高：如视频会议、直播、在线游戏等对时延敏感的应用。
- 广播和多播：如IPTV、网络广播，需要发送数据到多个接收者。
- 轻量级通信：如DNS查询、简单的网络服务探测等。

### 三、HTTP 是基于 TCP 的
HTTP（HyperText Transfer Protocol）是基于 TCP 的协议。
> HTTP/3.0 之前是基于 TCP 协议的，而 HTTP/3.0 将弃用 TCP，改用 基于 UDP 的 QUIC 协议 。

### 应用层协议的使用情况
1. 基于 TCP 的协议
- HTTP/HTTPS：用于网页浏览和安全的网页浏览。
- FTP：文件传输协议，用于文件上传和下载。
- SMTP：简单邮件传输协议，用于发送邮件。
- POP3/IMAP：用于接收邮件。
- Telnet/SSH：用于远程登录。

2. 基于 UDP 的协议
- DNS：域名系统，用于域名解析。
- DHCP：动态主机配置协议，用于动态分配IP地址。
- TFTP：简单文件传输协议，用于小文件传输。
- SNMP：简单网络管理协议，用于网络设备管理。
- VoIP：用于语音通信，如SIP协议。
- HTTP3.0

### TCP 的三次握手和四次挥手
- 三次握手  
1. SYN：客户端发送一个 SYN（同步）包给服务器，表示希望建立连接。
2. SYN-ACK：服务器收到 SYN 包后，回复一个 SYN-ACK 包，表示同意连接，并向客户端确认连接请求。
3. ACK：客户端收到 SYN-ACK 包后，发送一个 ACK 包，表示确认连接，连接建立成功。
> 三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。  
> 第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常。  
> 第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常。  
> 第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常。
> 三次握手就能确认双方收发功能都正常，缺一不可。

- 四次挥手
1. FIN：客户端发送一个 FIN（结束）包，表示不再发送数据。
2. ACK：服务器收到 FIN 包后，回复一个 ACK 包，确认接收到关闭请求。
3. FIN：服务器发送一个 FIN 包，表示不再发送数据。
4. ACK：客户端收到 FIN 包后，发送一个 ACK 包，确认接收，连接关闭。
> 第一次挥手：client 发送 FIN 确定自己不再发消息。    
> 第二次挥手：server 回复 ACK，表示我知道，你等下，可能消息还没发完。  
> 第三次挥手：server 发送 FIN，表示，我这边发完了。  
> 第四次挥手：client 回复 ACK，表示知道了，至此通信结束。  
> server 的 FIN 和 ACK 是不能合并的，因为 TCP 是全双工通信，server 此时可能消息还没发送完。

### TCP 如何保证网络可靠性
1. 确认机制：TCP 通过接收方发送的 ACK 确认包来确认数据是否成功接收，未收到确认包的数据将被重传。
2. 序列号：每个 TCP 数据包都带有一个序列号，接收方可以通过序列号来重组数据并检测丢失的包。
3. 重传机制：如果发送方在超时时间内没有收到 ACK 确认包，将重传该数据包。
4. 流量控制：通过滑动窗口机制，TCP 控制发送方的数据发送速率，防止网络拥塞和数据丢失。
5. 拥塞控制：TCP 实现了多种拥塞控制算法，如慢启动、拥塞避免、快速重传和快速恢复，动态调整发送速率以适应网络状况。

### TCP 如何解决拆包和粘包问题
粘包问题是指多个小数据包在传输过程中被粘在一起，接收方无法区分。  
拆包问题是指应用层数据过大，超出了 TCP 数据包的最大传输单元（MTU），需要分多个包进行传输。TCP 使用序列号和确认机制，接收方可以根据序列号将多个数据包重新组装成原始数据。

通过自定义 TCP 通信协议，增加魔数，协议版本，数据长度等，来区分每个数据包的边界，确保数据可以正确拆分。

> UDP 是面向报文的协议，每个报文是独立的，没有粘包问题。拆包问题在 UDP 中不常见，因为每个数据报文大小都在单独的 UDP 数据报中，应用层需要自行处理数据报文的分片和重组。

## IP

### IP 协议的定义

IP 协议是网络层的核心协议，用于在互联网上传输数据。它定义了数据包的封装格式和地址格式，并规定了数据如何从源主机传输到目标主机。IP 协议保证了数据能够在复杂的网络环境中找到最优路径到达目的地。

### 1.2 IP 协议的作用

- 数据传输：负责将数据从发送方传输到接收方，无论它们位于不同的网络中。
- 路由选择：根据 IP 地址和路由信息，选择最佳路径进行数据传输。
- 网络分段：允许将大型网络分割成更小的子网，方便管理和提高网络性能。
- 报头管理：IP 协议对数据包的报头进行管理，确保数据包可以被正确路由和传递。

### 什么是 IP 地址
IP 地址是一个唯一标识，用于标识网络中的每个设备。它类似于每台设备的“身份证”，用于在互联网上进行通信。IP 地址在数据包的头部，指示数据包的来源和目的地。

- IPv4 地址：由32位二进制数构成，通常表示为四个十进制数，每个数之间用点分隔（如 192.168.1.1）。
- IPv6 地址：由128位二进制数构成，通常表示为八个十六进制数，每个数之间用冒号分隔（如 2001:0db8:85a3:0000:0000:8a2e:0370:7334）。

### IP 如何寻址

IP 地址分为两部分：网络部分和主机部分。网络部分标识网络，主机部分标识网络内的设备。根据地址的前缀，可以确定网络的范围和设备在网络中的位置。

通过子网掩码将 IP 地址分成网络地址和主机地址。子网掩码是一组二进制位，用于划分网络和主机。常见的子网掩码有 255.255.255.0，表示前24位为网络部分，后8位为主机部分。

IP 协议通过路由表来决定数据包的传输路径。路由器使用路由表中的信息，将数据包转发到合适的网络接口，直到数据包到达目的地。

### 什么是 IP 过滤

- 防火墙：通过 IP 过滤来保护网络免受未授权访问。
- 访问控制：限制网络访问，确保只有授权用户才能访问特定资源。
- 流量管理：根据 IP 地址过滤数据包，管理网络流量，防止网络拥塞。

### IPv4 和 IPv6 的区别
1. 地址长度  
IPv4：32位地址，可以产生约42亿个地址。  
IPv6：128位地址，提供了340个十亿亿个地址，能够满足未来网络增长的需要。  

2. 地址表示  
IPv4：使用点分十进制表示（如 192.168.1.1）。  
IPv6：使用冒号分十六进制表示（如 2001:0db8:85a3:0000:0000:8a2e:0370:7334）。  

3. 地址分配  
IPv4：地址短缺，需通过 NAT 和私有地址解决。  
IPv6：每台机器都有独立的地址，据说IPv6可以给地球每一粒沙子都分配一个IP地址，哈哈。  

4. 安全性
IPv4：没有内置的安全机制，需要借助 IPsec 实现安全通信。
IPv6：默认支持 IPsec，可以更好地保证数据传输的安全性。

### NAT 的作用
NAT（网络地址转换，Network Address Translation）是一种网络技术，用于在不同网络之间转换 IP 地址。它允许多个设备通过一个公网 IP 地址访问互联网。
> 交换机，路由器。

- 地址节省：允许多个设备共享一个公网 IP 地址，缓解 IPv4 地址不足的问题。
- 安全性：隐藏内部网络结构，保护设备免受外部攻击。
- 网络灵活性：方便网络重组和管理，不影响内部 IP 地址分配。


## ARP&RARP
ARP（地址解析协议，Address Resolution Protocol）和 RARP（逆地址解析协议，Reverse Address Resolution Protocol）是两个重要的协议，它们负责在局域网中将 IP 地址和 MAC 地址之间进行映射。

### ARP 协议
ARP（地址解析协议）是一种网络协议，用于将 IP 地址转换为对应的 MAC 地址。它是网络层和链路层之间的桥梁，确保数据包能够在局域网中正确传输。

#### ARP 的工作原理

ARP 使用广播机制来实现 IP 地址到 MAC 地址的解析：当一个主机需要知道另一个主机的 MAC 地址时，它会发送一个 ARP 请求广播包，包中包含目标主机的 IP 地址。目标主机收到 ARP 请求后，会发送一个 ARP 响应包，其中包含它的 MAC 地址。这个响应包是单播发送的，直接回到请求主机。

请求和响应的过程如下图所示：

```
    主机A (IP: 192.168.1.2)      主机B (IP: 192.168.1.3)
         |                              |
         |---ARP 请求广播: Who is 192.168.1.3?--->|
         |                              |
         |<---ARP 响应单播: 192.168.1.3 is AA:BB:CC:DD:EE:FF---|
         |                              |
```

#### ARP 缓存
为提高效率，主机会将解析结果存储在 ARP 缓存中。ARP 缓存是一张表，记录了 IP 地址和对应的 MAC 地址。当主机需要再次发送数据时，会先检查缓存，如果找到目标地址的映射，就不再发起新的 ARP 请求。

### RARP 协议
RARP（逆地址解析协议）是一种网络协议，用于将 MAC 地址转换为对应的 IP 地址。RARP发出要反向解析的 MAC 地址并希望返回其对应的 IP 地址，应答包括由能够提供所需信息的 RARP 服务器发出的 IP 地址。虽然发送方发出的是广播信息，RARP规定只有RARP服务器能产生应答。

1. 发送主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；
2. 本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；
3. 如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；
4. 如果不存在，RARP服务器对此不做任何的响应；
5. 源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。 

### ARP 欺骗和防护
ARP 欺骗（ARP Spoofing）是一种网络攻击，攻击者通过伪造 ARP 响应包，将自己的 MAC 地址冒充为其他主机的 MAC 地址，从而接收原本不属于自己的数据。ARP 欺骗通常用于实施中间人攻击（MITM），窃取或篡改数据。

#### ARP 欺骗的防护措施
- 静态 ARP 条目：在网络设备上手动配置静态 ARP 条目，防止 ARP 缓存被篡改。
- ARP 检测工具：使用网络监控工具检测异常的 ARP 流量。
- 安全网关：配置安全网关或防火墙，检测和阻止可疑的 ARP 流量。
- VPN 加密：通过加密网络通信，防止数据被截获或篡改。
> 可以了解下 libpcap 和 libnet，很容易进行 MAC 地址改变等网络包篡改。

## HTTP
HTTP（超文本传输协议，Hypertext Transfer Protocol） 是互联网最重要的协议之一，它定义了在客户端和服务器之间如何传输超文本数据。

### HTTP 协议概述

HTTP 是一种应用层协议，设计用于传输超文本和多媒体资源。它是无状态的，即每次请求都是独立的，不保留任何之前请求的信息。HTTP 采用请求-响应模型，客户端发送请求，服务器返回响应。

HTTP 协议最早由蒂姆·伯纳斯-李（Tim Berners-Lee）在 1989 年提出，用于在万维网上传输文档。随着互联网的发展，HTTP 经历了多次升级，从最初的 HTTP/0.9 到如今的 HTTP/3。

### HTTP 报文结构

HTTP 报文分为请求报文和响应报文。每种报文都包括三部分：起始行、头部字段和消息体。

#### 请求报文

- 起始行：包含请求方法、请求 URL 和 HTTP 协议版本（如 `GET /index.html HTTP/1.1`）。
- 头部字段：提供请求的元信息（如 `Host`、`User-Agent`、`Accept` 等）。
- 消息体：用于传输数据（如表单数据、文件等）。

#### 响应报文

- 起始行：包含协议版本、状态码和状态描述（如 `HTTP/1.1 200 OK`）。
- 头部字段：提供响应的元信息（如 `Content-Type`、`Content-Length`、`Set-Cookie` 等）。
- 消息体：包含实际的数据（如 HTML 文档、图片等）。

### HTTP 的工作过程

HTTP 使用客户端-服务器架构。客户端（通常是浏览器）发送请求给服务器，服务器处理请求后返回响应。请求和响应的基本流程如下：
1. 客户端发送请求：客户端发起一个 HTTP 请求，包含方法、URL、协议版本、头部字段和可选的消息体。
2. 服务器处理请求：服务器接收到请求后，解析请求头部和消息体，执行相应的操作（如访问数据库、生成页面等）。
3. 服务器发送响应：服务器将处理结果打包成 HTTP 响应，包含状态行、头部字段和可选的消息体，并发送给客户端。
4. 客户端接收响应：客户端接收并解析响应，显示结果或执行后续操作。



### HTTP 方法
- GET：请求获取指定资源的数据。该方法是幂等的，即多次请求不会改变资源状态。
- POST：向服务器提交数据，用于创建资源或执行操作。POST 请求可能会改变资源状态。
- PUT：用于更新或替换指定资源。PUT 请求也是幂等的。
- DELETE：请求删除指定资源。DELETE 请求也是幂等的。
- HEAD：与 GET 类似，但只请求资源的头部，不返回消息体。用于检查资源的元数据。
- OPTIONS：请求服务器返回支持的 HTTP 方法，用于查询服务器的能力。
- PATCH：用于局部更新资源，与 PUT 不同，PATCH 只修改资源的一部分。

### HTTP 状态码
- 1xx（信息性状态码）：表示请求已接收，继续处理。
  - 100 Continue：客户端应继续发送请求的剩余部分。
- 2xx（成功状态码）：表示请求已成功处理。
  - 200 OK：请求成功，服务器返回所请求的数据。
  - 201 Created：请求已成功，并且资源已被创建。
- 3xx（重定向状态码）：表示资源已移动，需要客户端采取进一步的操作。
  - 301 Moved Permanently：资源已永久移动到新位置。
  - 302 Found：资源暂时移动到新位置。
- 4xx（客户端错误状态码）：表示请求错误，客户端需修改请求。
  - 400 Bad Request：请求无效或无法解析。
  - 401 Unauthorized：未授权，需要身份验证。
  - 404 Not Found：未找到所请求的资源。
- 5xx（服务器错误状态码）：表示服务器处理请求时发生错误。
  - 500 Internal Server Error：服务器内部错误。
  - 503 Service Unavailable：服务暂时不可用。

### HTTP 版本

#### HTTP/0.9
仅支持 GET 方法，不支持头部字段和状态码。用于简单的文本传输。

#### HTTP/1.0
引入了头部字段、状态码和更多的请求方法（如 POST 和 HEAD），但每次请求都需要新建 TCP 连接。

#### HTTP/1.1
支持持久连接（Persistent Connection），减少了连接开销。引入了更多的缓存控制和错误处理机制。
- 持久连接：默认情况下，TCP 连接在传输完成后保持打开状态，可以复用，减少了连接的建立和拆除开销。
- 分块传输编码（Chunked Transfer Encoding）：允许服务器将响应分成多个部分发送，适合动态内容。

#### HTTP/2
引入二进制帧格式，提高了传输效率。支持多路复用（Multiplexing），可以在单个 TCP 连接上并行发送多个请求和响应。
- 多路复用：在一个连接中同时传输多个请求和响应，减少了延迟。
- 头部压缩：使用 HPACK 算法压缩头部字段，减少了传输的数据量。
- 服务器推送（Server Push）：服务器可以主动推送资源给客户端，减少了请求延迟。

#### HTTP/3
基于 QUIC 协议，使用 UDP 代替 TCP，进一步减少了延迟，提升了传输效率。
- 更快的连接建立：QUIC 在建立连接时结合了 TLS 的握手过程，减少了延迟。
- 更好的丢包处理：QUIC 在丢包时仅重传受影响的数据，不会阻塞其他数据流。
- 更高的安全性：QUIC 内置了 TLS 1.3，加密了所有的传输数据。

### HTTPS
HTTPS 是 HTTP 的安全扩展，通过 TLS（传输层安全协议，Transport Layer Security）加密传输数据，确保数据的机密性、完整性和真实性。HTTPS 的主要特点包括：
- 数据加密：使用对称加密和非对称加密保护数据，防止被窃听。
- 身份验证：通过数字证书验证服务器身份，防止中间人攻击。
- 数据完整性：使用哈希函数确保数据未被篡改。

### 常见的 HTTP 安全威胁
- 中间人攻击（MITM）：攻击者拦截并篡改客户端和服务器之间的通信。
- 跨站脚本攻击（XSS）：攻击者注入恶意脚本，窃取用户数据或执行恶意操作。
- 跨站请求伪造（CSRF）：攻击者诱使用户执行未授权的操作。

## WebSocket
WebSocket 是一种网络通信协议，基于 TCP 连接，旨在实现 Web 应用中的全双工、低延迟通信。它允许客户端和服务器之间建立持久连接，使得双方可以随时互相发送数据，无需频繁建立和关闭连接。

在现代 Web 应用中，实时数据传输和交互是非常重要的需求。传统的 HTTP 协议是基于请求-响应模型的，只能由客户端主动发起请求，服务器才能返回响应，这种模式在实时通信场景下效率较低。

WebSocket 协议正是为了解决这一问题而设计，它提供了全双工的通信通道，使得客户端和服务器之间可以在单一持久连接上进行双向数据传输，极大地提高了通信效率和实时性。

### WebSocket 的特点
- 双向通信：客户端和服务器可以同时发送和接收消息，提供实时的数据传输能力。
- 持久连接：WebSocket 连接建立后将一直保持，直到任意一方主动关闭，减少了频繁创建连接的开销。
- 低延迟：由于减少了 HTTP 的握手和请求/响应周期，WebSocket 提供了更快的数据传输。
- 数据帧传输：WebSocket 使用数据帧的形式传输消息，可以传输文本和二进制数据。

### WebSocket 的工作原理

#### WebSocket 握手过程
WebSocket 连接的建立过程被称为握手，它基于 HTTP 协议的升级机制。握手步骤如下：
1. 客户端请求升级：客户端通过标准的 HTTP 请求发送一个特殊的 WebSocket 握手请求，包含 `Upgrade: websocket` 头部字段。
2. 服务器响应升级：服务器收到握手请求后，验证请求是否合法，并返回一个包含 `Upgrade: websocket` 的响应，表示同意升级连接。
3. 连接建立：握手成功后，HTTP 协议升级为 WebSocket 协议，建立持久的 WebSocket 连接。

WebSocket 握手请求和响应示例如下：

握手请求：
```
GET /chat HTTP/1.1
Host: opentp.cn
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13
```

握手响应：
```
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
```

### WebSocket 的应用场景

- 实时聊天应用: WebSocket 可以实现高效的双向消息传递，使得用户在聊天应用中能够实时发送和接收消息，提供流畅的交互体验。
- 实时数据推送: 在股票交易、在线游戏等场景中，WebSocket 能够实现低延迟的数据推送，确保用户能够及时接收到最新的数据。
- 在线协作工具: 通过 WebSocket，可以实现多人协作编辑文档、绘图等应用，实时同步各用户的操作。
- IoT 数据传输: WebSocket 可以在物联网（IoT）设备和服务器之间建立持续的连接，实现设备状态的实时监控和数据传输。
> IoT 系统还是 TCP，UDP 使用比较多。


### WebSocket 的安全性

- 数据加密
WebSocket 支持通过 WSS（WebSocket Secure）使用 TLS 加密通信，确保数据在传输过程中不会被窃听和篡改。
- 授权与认证
可以在 WebSocket 握手过程中传递授权令牌（如 JWT），进行身份验证，确保只有经过授权的用户才能建立 WebSocket 连接。
- 防御 DoS 攻击
为了防止恶意用户通过大量连接消耗服务器资源，应该在 WebSocket 服务器上实现连接限制和速率限制，防止拒绝服务攻击（DoS）。

## PING

1. 测试网络连通性：`ping` 可以验证本地主机是否能够与远程主机进行通信。
2. 测量网络延迟：`ping` 通过测量从发送请求到接收响应的时间（往返时间，RTT），评估网络的响应速度。
3. 检查丢包率：通过发送多个请求并统计响应，`ping` 可以检测网络中是否存在数据包丢失。

### ICMP 协议
`ping` 使用 ICMP 协议，ICMP 是 TCP/IP 协议族中的一个辅助协议，用于发送错误消息和操作信息。`ping` 主要使用 ICMP 中的两种报文：
- ICMP 回显请求（Echo Request）：由发起 `ping` 的主机发送，用于请求目标主机的响应。
- ICMP 回显应答（Echo Reply）：由目标主机响应回显请求，用于确认请求的接收。

### `ping` 命令执行过程
1. 发送 ICMP 回显请求：发起 `ping` 的主机向目标主机发送一个 ICMP 回显请求报文，报文中包含了发送时间戳和唯一的标识符。
2. 目标主机接收请求：目标主机接收到 ICMP 回显请求后，检查报文的有效性。
3. 目标主机发送应答：目标主机根据收到的请求，构造一个 ICMP 回显应答报文，并将其发送回发起 `ping` 的主机。
4. 接收 ICMP 回显应答：发起 `ping` 的主机接收到 ICMP 回显应答报文，计算从发送请求到接收应答的时间，作为 RTT（往返时间）。
5. 统计结果：`ping` 工具会发送多个 ICMP 请求，并根据接收到的应答统计响应时间、丢包率等信息。


## DNS

DNS（Domain Name System，域名系统） 是互联网的一项核心技术，它将人类易于记忆的域名（如 `www.opentp.cn`）转换为计算机用于通信的 IP 地址（如 `10.184.216.34`）。
> 网络世界的电话簿

DNS 是一种分布式数据库系统，负责将域名解析为 IP 地址，使得用户可以通过易记的域名访问互联网资源。它的主要功能包括：
- 域名解析：将域名转换为 IP 地址。
- 反向解析：将 IP 地址转换为域名。
- 提供邮箱服务器地址：为邮件系统提供邮件服务器的 IP 地址。
- 负载均衡：通过返回不同的 IP 地址，分散流量。

### DNS 查询流程
当用户在浏览器中输入一个域名时，DNS 会执行一系列步骤来解析该域名，流程如下：
1. 本地缓存查询：浏览器首先检查本地缓存中是否有对应的 IP 地址。
2. 操作系统缓存查询：如果浏览器缓存没有找到，操作系统会检查系统缓存。
3. 本地 DNS 服务器查询：如果操作系统缓存也没有找到，请求会发送到本地 DNS 服务器（通常由 ISP 提供）。
4. 递归查询：如果本地 DNS 服务器没有记录，它会发起递归查询，从根域名服务器开始逐级查询。

### 递归查询过程

1. 根域名服务器：返回顶级域（TLD，如 .com）的 DNS 服务器地址。
2. TLD DNS 服务器：返回次级域（如 example.com）的权威 DNS 服务器地址。
3. 权威 DNS 服务器：返回最终的 IP 地址。

最终，DNS 服务器将查询结果返回给客户端，客户端可以使用 IP 地址与目标服务器建立连接。


### DNS 服务器
- 根域名服务器：负责解析顶级域名，全球只有 13 台根服务器。
- 顶级域名服务器（TLD）：负责解析特定顶级域名下的请求。
- 权威 DNS 服务器：存储具体域名和对应 IP 地址的记录，提供最终解析结果。
- 递归解析服务器：接收 DNS 查询请求，逐级向上查询，直至找到结果。

### DNS 的重要性

DNS 是互联网基础设施的重要组成部分，确保了用户能够方便、快速地访问网站和其他网络资源。理解 DNS 的工作原理，对于网络管理、故障排查和提高网络访问效率至关重要。


### DNS 劫持简介及应对措施

DNS 劫持 是一种网络攻击方式，通过篡改 DNS 解析过程，将合法域名指向恶意 IP 地址，诱导用户访问虚假的网站。

DNS 劫持（DNS Hijacking）将用户对合法域名的请求重定向到恶意网站。这些网站可能包含钓鱼页面、恶意软件或其他有害内容。DNS 劫持可以发生在 DNS 服务器上、用户设备上，或者网络通信过程中。

#### DNS 劫持的常见类型
1. 路由器 DNS 劫持  
攻击者通过漏洞或弱密码访问家庭或办公路由器，更改其 DNS 服务器设置。所有通过该路由器的流量都会使用被篡改的 DNS 服务器进行域名解析，用户被重定向到恶意网站。
2. 客户端 DNS 劫持
恶意软件或病毒在用户的设备上篡改 DNS 设置，指向攻击者控制的 DNS 服务器。这样一来，用户的所有域名请求都会被劫持。
3. ISP DNS 劫持
一些互联网服务提供商（ISP）可能会篡改 DNS 请求，将用户重定向到包含广告或其他内容的页面。这种情况常见于免费 Wi-Fi 或一些不规范的网络服务提供商。
4. DNS 服务器劫持
攻击者通过漏洞或社会工程学手段，获得对 DNS 服务器的控制权，篡改域名解析记录。这样，所有用户访问该域名时都会被重定向到攻击者指定的 IP 地址。
5. 中间人攻击
攻击者在网络传输过程中拦截并篡改 DNS 请求或响应数据包，改变解析结果。用户会被重定向到恶意网站，而不会察觉请求已被篡改。

#### 如何应对 DNS 劫持
- 更改默认登录凭证：更改路由器的默认用户名和密码，避免被攻击者轻易入侵。
- 更新固件：定期检查并更新路由器的固件，以修复已知漏洞。
- 禁用远程管理：关闭路由器的远程管理功能，减少被远程攻击的风险。
- 使用安全 DNS 服务器：配置路由器使用可信任的 DNS 服务器，如 Google DNS（8.8.8.8，8.8.4.4）或 OpenDNS（208.67.222.222，208.67.220.220）。
- 安装和更新防病毒软件：使用可靠的防病毒软件并保持其更新，防止恶意软件篡改 DNS 设置。
- 避免安装来路不明的软件：下载软件时应选择官方渠道，避免被恶意软件感染。
- 定期检查 DNS 设置：在系统中定期检查 DNS 设置是否被篡改。
- 使用加密的 DNS 服务：采用 DNS over HTTPS（DoH）或 DNS over TLS（DoT）等加密方式，防止 DNS 请求被中间人攻击劫持。
- 选择公共 DNS 服务器
- 启用 DNSSEC：DNSSEC（DNS Security Extensions）是一种安全协议，能够验证 DNS 数据的真实性，防止 DNS 劫持和污染。
- 使用网络防火墙：配置防火墙阻止非法的 DNS 流量，监控网络中异常的 DNS 请求。
- 部署入侵检测系统（IDS）：使用 IDS 监控网络中的恶意行为，及时发现和应对 DNS 劫持攻击。
- 提高用户安全意识：教育用户识别钓鱼网站，不点击来历不明的链接，避免访问可疑网站。
- 定期更改密码：定期更改重要账户和设备的密码，使用强密码策略。
- 分布式 DNS：部署多个地理位置不同的 DNS 服务器，减少单点故障和被劫持的风险。
- 定期审计 DNS 配置：企业应定期审查和更新 DNS 配置，及时修复漏洞和不合理的配置。