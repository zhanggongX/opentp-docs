---
title: 240409-1702修改后的最大二进制字符串
category:
  - leetcode
order: 3
tag:
  - 贪心
  - 字符串
---

给你一个二进制字符串 binary ，它仅有 0 或者 1 组成。你可以使用下面的操作任意次对它进行修改：

操作 1 ：如果二进制串包含子字符串 "00" ，你可以用 "10" 将其替换。  
比方说， "00010" -> "10010"  

操作 2 ：如果二进制串包含子字符串 "10" ，你可以用 "01" 将其替换。  
比方说， "00010" -> "00001"  

请你返回执行上述操作任意次以后能得到的 最大二进制字符串 。如果二进制字符串 x 对应的十进制数字大于二进制字符串 y 对应的十进制数字，那么我们称二进制字符串 x 大于二进制字符串 y 。

### 题解
答案肯定只有一个0，如果有多个0，可以通过一系列 10 -> 01 操作可以让多个 0 到一块，然后可以通过 00 -> 10 得到的数肯定比之前的大。  
而且 0 只能左移，不能右移

设字符串长度为 len，  
我们先找到第一个 0 设它的索引位置为 i，然后统计字符串索引 (i, len] 中的 1 的个数记为 count1。  
根据规律，最终这 count1 个 1 都会到字符串的末尾，那么最终的字符串，  
就是 len - 1 - count1 个 1 + 一个 0 + count1 个 1。  
>比如 101010，第一个 0 位置为 1，统计后续有 2 个 1，  
最终结果是 101010 -> 100011 -> 11011 即 6-1-2(2) 个 1 + 一个 0 + 两个 1。  
>还比如 11110 这种情况，第一个 0 的位置就在最后了，统计到的 1 个数为 0，  
所以答案是 4 个 1 + 一个 0，和原字符串一致。

```java
class Solution {
    public String maximumBinaryString(String binary) {
        int i = binary.indexOf('0');
        if (i < 0) {
            // 如果字符串全是 1，直接返回。
            return binary;
        }

        char[] s = binary.toCharArray();
        int count1 = 0;

        // 从第一个 0 的位置往后遍历
        for (i = i+1; i < s.length; i++) {
            count1 += s[i] - '0'; 
        }
        return "1".repeat(s.length - 1 - count1) + '0' + "1".repeat(count1);
    }
}
```