---
title: 分布式ID
category:
  - 分布式
order: 4
tag:
  - distributed
  - 分布式ID
---

## 为什么需要分布式ID
但随着数据日渐增长，有可能需要对数据库进行分库分表，分库分表后仍需要有一个唯一ID来标识一条数据，数据库的自增ID显然不能满足需求；  
特别一点的如订单，也需要分布式ID，因为哪怕订单的数据量小也最后不要使用自增ID，因为使用自增ID，很容易让别人猜到整个系统一天的单量。。

## 分布式ID基本要求
1. **全局唯一**
2. **高性能**
3. **高可用**
4. **方便易用**
5. **安全**：ID 中不包含敏感信息。
6. **有序递增**
7. **可以有具体的业务含义**
8. **独立部署**

## 分布式ID解决方案
### UUID（不推荐）
- **优点**：生成速度比较快、简单易用，本地生成无网络消耗，具有唯一性（重复概率很小）。
- **缺点**：无序、存储消耗空间大、不安全、没有具体业务含义、需要解决重复ID问题，因为大部分ID还是Mysql数据库在使用，还是推荐递增ID，所以UUID还是不怎么合适。

### 数据库主键
数据库主键自增

- **优点**：实现简单，ID单调自增，数值类型查询速度快、存储消耗空间小。
- **缺点**：DB单点存在宕机风险，无法扛住高并发场景。

### 数据库的号段模式
```SQL
CREATE TABLE id_generator (
  id int(10) NOT NULL,
  max_id bigint(20) NOT NULL COMMENT '当前最大id',
  step int(20) NOT NULL COMMENT '号段的布长',
  biz_type	int(20) NOT NULL COMMENT '业务类型',
  version int(20) NOT NULL COMMENT '版本号',
  PRIMARY KEY (`id`)
) 
```
一批批号段ID用完，再次向数据库申请新号段，对max_id字段做一次update操作，update max_id= max_id + step，update成功则说明新号段获取成功，新的号段范围是(max_id ,max_id +step]。
由于多业务端可能同时操作，所以采用版本号version乐观锁方式更新，这种分布式ID生成方式，不会频繁的访问数据库，对数据库的压力小很多。

### NoSql(Redis) incr
Redis不同的持久化方式，会有不同的问题。
1. RDB会定时打一个快照进行持久化，如果Redis挂掉了，重启后会出现ID重复的情况。
2. AOF会对每条写命令进行持久化，由于incr命令的特殊性，会导致Redis重启恢复的数据时间过长。

### 雪花算法
Snowflake 是 Twitter 开源的分布式 ID 生成算法。Snowflake 由 64 bit 的二进制数字组成，这 64bit 的二进制被分成了几部分，每一部分存储的数据都有特定的含义：  
1. sign(1bit): 符号位（标识正负），始终为 0，代表生成的 ID 为正数。
2. timestamp (41 bits): 一共 41 位，用来表示时间戳，单位是毫秒，可以支撑 2 ^41 毫秒（约 69 年）
3. datacenter id + worker id (10 bits): 前 5 位表示机房 ID，后 5 位表示机器 ID。这样就可以区分不同集群/机房的节点。
4. sequence (12 bits): 一共 12 位，用来表示序列号。 序列号为自增值，代表单台机器每毫秒能够产生的最大 ID 数(2^12 = 4096), 单台机器每毫秒最多可以生成 4096 个 唯一 ID。

> 优点：生成速度比较快、生成的 ID 有序递增、比较灵活，可以进行改造。  
> 缺点：需要解决重复 ID 问题（ID 生成依赖时间，在获取时间的时候，可能会出现时间回拨的问题）， 依赖机器 ID 对分布式环境不友好， 固定的机器 ID 可能不够灵活。

### Mist 薄雾算法
薄雾算法 Mist 由书籍《Python3 反爬虫原理与绕过实战》的作者韦世东综合 百度 UidGenerator、 美团 Leaf 和 微信序列号生成器 seqsvr 中介绍的技术点，同时考虑高性能分布式序列号生成器架构后设计的一款“递增态势、不依赖数据库、高性能且不受时间回拨影响”的全局唯一序列号生成算法。  

相比 snowflake ，薄雾算法具有更高的数值上限和更长的使用期限，以及更高的性能。
薄雾算法采用了与 snowflake 相同的位数——64位，采用了 1-47-8-8 的占位。
- 第一段为最高位，占 1 位，保持为 0，使得值永远为正数；
- 第二段放置自增数，占 47 位，自增数在高位能保证结果值呈递增态势，遂低位可以为所欲为；
- 第三段放置随机因子一，占 8 位，上限数值 255，使结果值不可预测；
- 第四段放置随机因子二，占 8 位，上限数值 255，使结果值不可预测；

#### 优点：
1. 没有时间回拨问题：  

薄雾算法不受时间戳影响，受到数值大小影响。薄雾算法高位数值上限计算方式为int64(1<<47 - 1)，上限数值140737488355327 百万亿级，假设每天消耗 10 亿，薄雾算法能使用 385+ 年。
snowflake 受时间回拨影响的根本原因是高位采用时间戳的二进制值，而薄雾算法的高位是按序递增的数值。结果值的大小由高位决定，遂薄雾算法不受时间回拨影响。

考虑到“不可预测”的要求，薄雾算法的中间位是 8 位随机值，且末 8 位是也是随机值，两组随机值大大增加了预测难度，因此称为结果值不可预测。  
中间位和末位随机值的开闭区间都是 [0, 255]，理论上随机值可以出现 256 * 256 种组合。

#### 缺点：
1. 重启后不保证递增

薄雾算法中的高位是按序递增的数值，程序重启会造成按序递增数值回到初始值，但由于中间位和末尾随机值的影响，因此不是必定生成（有大概率生成）重复 ID，但递增态势必定受到影响。





## 分布式ID框架
- UidGenerator(百度、Snowflake)  
- Leaf(美团，Snowflake)  
- Tinyid(滴滴，数据库号段模式)
- IdGenerator(Snowflake)
