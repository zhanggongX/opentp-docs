---
title: 分布式锁
category:
  - 分布式
order: 5
tag:
  - distributed
  - 分布式锁
---

## 介绍
多个进程需要对同一共享资源进行访问/修改，本进程内锁的这时时不起作用的，这时就需要分布式锁。

## 分布式锁的基本要求
1. 互斥，最最最基本要求
2. 高可用，不能死锁
3. 高性能，不能成为性能瓶颈
4. 可以非阻塞
5. 可重入，属于进阶能力

## 常见实现方案
- 基于数据库 Mysql 等锁表实现，少见。
- 基于 Redis 实现，较为常见。
- 基于 ZooKeeper 实现，较为常见。
- 基于 Etcd 实现，较少。
- 基于 Consul 实现，较少。

### 基于数据库
1. 增加锁记录，加锁插入一条记录，解锁删除该记录。
2. 基于数据库排他锁 select * from table_x for update。
3. 数据上增加乐观锁，增加版本。
> 不推荐：性能太差、不具备锁失效机制，数据库单点问题，不可重入。

### 基于 redis
方法一：set nx   
加锁30秒  
SET lockKey lockValue EX 30 NX
> 删除锁的时候可以校验一下 lockValue 使用 lua 脚本实现

方法二：
redis + lua 脚本

#### Redisson 锁续期
可以使用 Redisson 来解决锁续期问题，原理是某一线程加锁成功，启动一个 watch dog，每 10 秒去检查一下，如果还是该线程持有锁，就会延长锁的时间。  
watch dog 其实就是一个后台线程，定时执行去检查。   
未指定锁超时时间才会使用 watch dog。  

#### Redisson 可重入
给锁关联一下线程信息和重入次数，每次加锁判定，相同的线程重入次数+1，解锁相应的-1。

#### Redis 集群
Redlock 算法的思想是让客户端向 Redis 集群中的多个独立的 Redis 实例依次请求申请加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败。  
但是可能会比较慢。  
Redisson 也有对 Redlock 算法的实现。

### 基于 ZooKeeper 实现分布式锁
Redis 实现分布式锁性能较高，ZooKeeper 实现分布式锁可靠性更高。实际项目中，我们应该根据业务的具体需求来选择。  
ZooKeeper 的节点一共有四种，普通持久节点，普通临时节点，顺序持久节点，顺序临时节点。  
基于 ZK 的分布式锁，就是利用顺利临时节点的特点 + watcher 机制来实现分布式锁。  

#### 加锁
1. 首先我们要有一个持久节点 /locks ，客户端获取锁就是在 /locks 下创建临时顺序节点。  
2. 假设客户端 Thread_A 创建了/locks/lock00000001 节点，创建成功之后，会判断 lock00000001 是否是 /locks 下最小的子节点。  
3. 如果 lock00000001 是最小的子节点，则获取锁成功。否则，获取锁失败。  
4. 如果获取锁失败，则说明有其他的客户端已经成功获取锁。客户端 Thread_A 并不会不停地循环去尝试加锁，而是在前一个节点比如 /locks/lock00000001 - 1 上注册一个事件监听器。
5. 当前一个节点释放锁之后通知客户端 Thread_A，这样客户端 Thread_A 就加锁成功了。

##### 解锁
1. 成功获取锁的客户端在执行完业务流程之后，会将对应的子节点删除。
2. 成功获取锁的客户端在出现故障之后，对应的子节点由于是临时顺序节点，也会被自动删除，避免了锁无法被释放。
3. 我们前面说的事件监听器其实监听的就是这个子节点删除事件，子节点删除就意味着锁被释放。

### 使用
建议使用 Curator 框架。  
Curator 实现了 分布式可重入排他锁，分布式不可重入排他锁，分布式读写锁，多锁（将多个锁作为一个锁，同时获取多个锁，同时释放多个锁）    
[Curator 使用示例](https://juejin.cn/post/6844903632064741384)