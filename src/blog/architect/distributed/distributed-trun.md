---
title: 分布式事务
category:
  - 分布式
order: 6
tag:
  - distributed
  - 分布式事务
---

## 分布式事务介绍
> 事务是一个程序执行过程，这个过程中的所有操作要么全部执行成功，要么全部执行失败。  
> 在分布式系统中，程序执行是在不同的服务器或者说进程中的，需要保证多个进程整个链路要么成功，要么失败，这便是分布式事务。  

说到分布式就肯定离不开分布式的理论基础 CAP 理论，所以分布式事务也可以理解为，如果发送网络分区（某个服务异常），整个服务链路，保证强一致性还是最终一致性。  
即分布式事务分为 CP 模型和 AP&BASE 模型。
### CP 刚性事务&强一致性事务
包括 XA协议（2PC,JTA,JTS），3PC 等。

### AP&BASE 柔性事务，最终一致性事务
包括 补偿型的 Seata(TCC), SAGA，通知型的，MQ事务消息，本地消息表，LCN-TCC。

## 分布式事务概念
- 事务： 事务是由一组操作构成的可靠的独立的工作单元，事务具备ACID的特性。
- 本地事务：当事务由资源管理器本地管理时被称作本地事务。本地事务的优点就是支持严格的ACID特性。
- 全局事务：当事务由全局事务管理器进行全局管理时成为全局事务，事务管理器负责管理全局的事务状态和参与的资源，协同资源的一致提交回滚。
- TX 协议：应用服务器与事务管理器的接口。
- XA 协议：全局事务管理器与资源管理器的接口。
> XA 是由 X/Open 组织提出的分布式事务规范。  
> 该规范主要定义了全局事务管理器和局部资源管理器之间的接口。  
> 主流的数据库产品都实现了XA接口。XA接口是一个双向的系统接口，在事务管理器以及多个资源管理器之间作为通信桥梁。  
> 之所以需要XA是因为在分布式系统中从理论上讲两台机器是无法达到一致性状态的，因此引入一个单点进行协调。  
> 由全局事务管理器管理和协调的事务可以跨越多个资源和进程。  
> 全局事务管理器一般使用XA二阶段协议与数据库进行交互。
- AP：应用程序，可以理解为使用DTP（Data Tools Platform）的程序。
- RM：资源管理器，这里可以是一个DBMS或者消息服务器管理系统，应用程序通过资源管理器对资源进行控制，资源必须实现XA定义的接口。资源管理器负责控制和管理实际的资源。
- TM：事务管理器，负责协调和管理事务，提供给AP编程接口以及管理资源管理器。事务管理器控制着全局事务，管理事务的生命周期，并且协调资源。
- 2PC：XA 用于在全局事务中协调多个资源的机制。TM 和 RM之间采取 两阶段提交 的方案来解决一致性问题。 两阶段提交需要一个协调者（TM）来掌控所有参与者（RM）节点的操作结果并且指引这些节点是否需要最终提交。两阶段提交的局限在于协议成本，准备阶段的持久成本，全局事务状态的持久成本，潜在故障点多带来的脆弱性，准备后，提交前的故障引发一系列隔离与恢复难题。
- 3PC: 是对两段提交（2PC）的一种升级优化，3PC 在 2PC 的第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前，各参与者节点的状态都一致。同时在协调者和参与者中都引入超时机制，当参与者各种原因未收到协调者的commit请求后，会对本地事务进行commit，不会一直阻塞等待，解决了2PC的单点故障问题，但3PC还是没能从根本上解决数据一致性的问题。
- JTA: Java事务API（Java Transaction API），在Java环境中，允许完成跨越多个XA资源的分布式事务。
- JTS: Java事务服务（Java Transaction Service）J2EE 服务器提供商根据JTS规范实现事务并提供JTA接口。
- TCC: try-confirm-cancel。
- SAGA: Saga是由一系列的本地事务构成。每一个本地事务在更新完数据库之后，会发布一条消息或者一个事件来触发Saga中的下一个本地事务的执行。如果一个本地事务因为某些业务规则无法满足而失败，Saga会执行在这个失败的事务之前成功提交的所有事务的补偿操作。

## 分布式事务详解
### 刚性事务详解

#### XA模型
分为三个角色，AP（应用程序），TM（事务管理器），RM（资源管理器）  
XA模型方法。  
xa_open, xa_close：建立和关闭与资源管理器的连接。  
xa_start, xa_end：开始和结束一个本地事务。  
xa_prepare, xa_commit, xa_rollback：预提交、提交和回滚一个本地事务。  
xa_recover：回滚一个已进行预提交的事务。  
ax_reg,ax_unreg；允许一个资源管理器在一个TMS(TRANSACTION MANAGER SERVER)中动态注册或撤消注册。  
2PC协议就是XA模型的实现（一阶段提交事务，二阶段执行事务，如果出现意外二阶段进行回滚)  
3PC协议是XA模型的扩展  
> 总结介绍就是， XA 模型，引入一个作为协调者（TM）的组件来统一掌控所有参与者 AP 的操作结果，并最终发出指令这些节点是否要把操作结果进行真正的提交。  
> XA模型 也有很多风险，
> 1. 比如网络抖动导致接收到事务管理器发送的消息部分应用没有收到，就会导致整个系统不一致。
> 2. XA 模型时强一致性的，也就是说短时事务要阻塞在长时事务这里。
> 3. 事务管理器本身也有可能出问题。


### 柔性事务

#### 补偿型-TCC
TCC 的全称是：Try、Confirm、Cancel。
- Try 阶段：这个阶段说的是对各个服务的资源做检测以及对资源进行锁定或者预留。
- Confirm 阶段：这个阶段说的是在各个服务中执行实际的操作。
- Cancel 阶段：如果任何一个服务的业务方法执行出错，那么这里就需要进行补偿，就是执行已经执行成功的业务逻辑的回滚操作。

缺点：
1. 也需要引入第三方事务协调服务。
2. 事务回滚严重依赖于代码来回滚和补偿，有一定的实现压力。
3. 空回滚，未执行 try 出现异常，也会执行 cancel 方法，可能有幂等问题。

#### 补偿型-Saga事
Saga是由一系列的本地事务构成。  
每一个本地事务在更新完数据库之后，会发布一条消息或者一个事件来触发Saga中的下一个本地事务的执行。  
如果一个本地事务因为某些业务规则无法满足而失败，Saga会执行在这个失败的事务之前成功提交的所有事务的补偿操作。  

Saga的实现有很多种方式，其中最流行的两种方式是：
1. 基于事件的方式。
> 这种方式没有协调中心，处于当前Saga下的各个服务，会产生各种事件，也要监听其它服务产生的事件并决定是否需要针对监听到的事件做出响应，即提交或者执行回滚补偿代码。
2. 基于命令的方式。
> 这种方式需要一个（协调中心），来协调所有服务，协调中心来告诉Saga的参与方应该执行哪一个本地事务。

#### 通知型-MQ事务

[MQ事务的实现示例](https://opentp.cn/blog/architect/distributed/rocket-mq-trun.html)

整体流程就是事务主动方发出事务消息，事务消息回调本地事务，本地消息执行成功，事务被动方才能接收到事务消息。
如果本地事务执行失败，或者没有提交本地事务，事务消息会定时回查本地事务状态，如果失败或者到一定次数，删除事务消息。

优点：
- 消息数据独立存储 ，降低业务系统与消息系统之间的耦合。
- 吞吐量大于使用本地消息表方案。
- 使用简单  

缺点：
- 一次消息发送需要两次网络请求(half 消息 + commit/rollback 消息) 。
- 业务处理服务需要实现消息状态回查接口。


#### 通知型-最大努力通知方案
是对MQ事务方案的进一步优化。它在事务主动方增加了校对的接口，即接事务被动方收事务消息的同时，也主动去拉取去校对事务。  

## Seata
Seata 是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。  
Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式。  
[seata 官网](https://seata.apache.org/zh-cn/docs/overview/what-is-seata/)

### Seata 示例（todo）