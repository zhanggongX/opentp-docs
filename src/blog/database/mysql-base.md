---
title: MySQL基础
category:
  - 数据库
order: 2
tag:
  - 数据库
  - mysql
---

## MySQL 基础知识
### char 和 varchar 
1. char 是定长字符串，用来存储电话号，身份证号等长度一致的字符串。
2. varchar 是变长字符串，用来存储姓名，标题等内容。
3. char 如果存入的内容长度不到定义长度，会在右边填充空格，但是搜索时会去掉空格。
4. varchar 存储时需要一个或两个额外**字节**记录字符串的长度，搜索时不需要处理。
5. varchar 并不是设置的越大越好，请设置合理的长度，因为它虽然是变长的，设置的较大时不会占用资盘空间，但是搜索时 varchar 在内存中通常分配设置的大小的内存快来保存，例如排序时 varchar 就是按照设置的长度进行的，所以要设置合理的长度。

### TEXT 和 BLOB
TEXT 类型类似于 CHAR（0-255 字节）和 VARCHAR（0-65,535 字节），但可以存储更长的字符串，即长文本数据。  
TINYTEXT(0-255) / TEXT(0-65535)  / MEDIUMTEXT(0-16MB) / LONGTEXT(0-4GB)  

BLOB 存储二进制字符串，长度和 TEXT 差不多。

但是不建议使用：
1. 不能有默认值
2. 无法使用内存临时表
3. 只能使用前缀索引
4. 消耗大量网络IO
5. DML 可能变慢

并不是不允许存储这两种内容的字段，如果真的需要可以单独建表存储，如果内容过大，还是建议使用对象存储。

### 不建议使用 NULL
1. 不能使用 = 判断，只能使用 is NULL \ is not NULL  
2. 值不确定， select NULL = NULL 结果为 false;
3. 聚合函数会忽略 NULL
4. Count 函数如果 count(*) 会统计到 NULL 的行，如果 count(列) 则统计不到 NULL 的行，导致结果不一致。
5. '' 不占用空间， NULL 反而占用空间。

### DATETIME&TIMESTAMP
DATETIME 类型没有时区信息，TIMESTAMP 和时区有关。  
TIMESTAMP 需要 4 个字节的存储，DATETIME 需要 8 个字节。  
Timestamp 表示的时间范围更小：1970-01-01 00:00:01 ~ 2037-12-31 23:59:59。 DATETIME：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59  

## Mysql SQL 执行过程
连接器 -> (缓存) -> 分析器 -> 优化器 -> 执行器 -> 存储引擎。
- 连接器 链接权限认证
- 缓存 8.0 已弃用，建议关闭
- 分析器 sql 解析
- 优化器 sql 解析后生成最优执行方案
- 插件式存储引擎 数据的存储和读取
> 为什么缓存要弃用，
> 1. 两次查询任何一点变化都会导致缓存不命中。 
> 2. 查询中包含任何用户自定义函数，存储函数，用户变量，临时表，系统表，都不会缓存。  
> 3. 相关的表的任何变动，相关的表的缓存都会失效.

## MySQL 存储引擎
5.5 之前默认是 MyISAM 5.5 之后是 InnoDB。现在几乎都是使用 InnoDB
两者的区别：
1. 是否支持事务。
2. 是否支持表锁。
3. 是否支持外键。
4. 是否支持 MVCC。
5. 是否支持数据恢复。  
毫无疑问：上边几种 InnoDB 支持 MyISAM 都不支持。

## MySQL 事务
### 事务即 ACID 
1. 原子性（Atomicity)
2. 一致性（Consistency)
3. 隔离性（Isolation)
4. 持久性（Durabiltiy)
其实 AID -> C

### 事务并发的问题
1. 脏读，一个事务读到了另一个事物未提交的数据。
2. 修饰修改，两个事务并发执行，后提交的事务覆盖了前提交的事务的结果。
3. 不可重复读，一个事务读取数据，读取到的两次数据不一致。
4. 幻读，一个事务读取数据，读取到的两次数据条数不一致。

> 其实解决事务并发问题就两种:
>- 锁
>- MVCC

### MySQL 事务隔离级别
- read-uncommited 读未提交
- read-commited 读已提交 （解决脏读问题）
- repeateble-read 可重复读 （解决脏读、不可重复读）（默认的）
- serializable 串行化 （解决所有事务并发问题）

## MySQL 的锁
### MySQL的锁按照控制方式分为 **共享锁（S）** 和 **排他锁（X）**。
1. 共享锁： 读锁，允许事务读取记录时获取共享锁，允许多个事务同时获取。
2. 排他锁： 写锁/独占锁，事务独占。
> 普通 select 不会加任何锁，   
> select .. for share -- 加共享锁   
> select .. for update -- 加排他锁  
> 表级锁和行级锁，都支持共享锁和排他锁。

###  按照锁的粒度，MySQL的锁又分为 **表级锁** 和 **行级锁**。
行级锁又分为：
- 记录锁(record lock)，仅锁单行记录
- 间隙锁（gap lock)，锁定一个范围，不包括记录本身
- 临键锁（next-key lock), 记录锁+间隙锁，锁定一个范围，包含记录本书，主要是为了解决 RR 事务隔离级别下幻读的问题。
> RR 事务隔离级别默认使用 Next-key lock 但是操作的索引是唯一索引或者主键，InnoBD 会把 Next-key lock 降级成 Record lock。

### 意向锁
意向锁只有表锁，它的用途就是为了快速判断是否可以加表锁。意向锁是 Mysql 控制的，我们写程序无法控制。  
> 例如某个事务需要加表锁，但是它去判断某个行是否有行锁，效率就特别低，所以 Mysql 增加了意向锁。  
> 我们需要给数据库某些行增加锁，要先获得相应的意向锁，这样事务再去加表锁的时候，只需要判断意向锁即可。

### MVCC 多版本并发控制
一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。  
通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。  
MVCC 在 MySQL 中实现所依赖的手段主要是: 
- 隐藏字段（TXID）
- read view
- undo log

undo log : undo log 用于记录某行数据的多个版本的数据。  
read view 和 隐藏字段 : 用来判断当前版本数据的可见性。  

### 当前读和快照读