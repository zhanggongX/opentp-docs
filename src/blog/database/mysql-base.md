---
title: MySQL基础
category:
  - 数据库
order: 2
tag:
  - 数据库
  - mysql
---

## Mysql SQL 执行过程
连接器 -> (缓存) -> 分析器 -> 优化器 -> 执行器 -> 存储引擎。
- 连接器 链接权限认证
- 缓存 8.0 已弃用，建议关闭
- 分析器 sql 解析
- 优化器 sql 解析后生成最优执行方案
- 插件式存储引擎 数据的存储和读取
> 为什么缓存要弃用，
> 1. 两次查询任何一点变化都会导致缓存不命中。 
> 2. 查询中包含任何用户自定义函数，存储函数，用户变量，临时表，系统表，都不会缓存。  
> 3. 相关的表的任何变动，相关的表的缓存都会失效.
> 4. 虽然缓存有时可以提升系统性能，但是维护缓存的开销也大。所以，从 MySQL5.7.20 开始，不再推荐使用查询缓存，并在 MySQL8.0 中删除。

## Mysql 支持的字符集和排序规则
#### 字符集
可以通过 `show charset` 查看。  
不同的版本支持的字符集不同，比较常用的字符集有 ascii、gb2312、utf8（即utf8mb3，是utf8的精简版，使用1～3个字节表示字符）、utf8mb4（推荐使用，使用1～4个字节表示字符，支持emoji表情）。
#### 比较规则
比较规则用来比较某种编码的字符大小，一般排序的时候用到。
```sql
-- 查看 utf8 的比较规则
-- utf8 的默认比较规则是 utf8_general_ci （不区分大小写）
show collation like 'utf8\_'
```

## MySQL 基础知识
### char 和 varchar 
1. char 是定长字符串，用来存储电话号，身份证号等长度一致的字符串。
2. varchar 是变长字符串，用来存储姓名，标题等内容。
3. char 如果存入的内容长度不到定义长度，会在右边填充空格，但是搜索时会去掉空格。
4. varchar 存储时需要一个或两个额外**字节**记录字符串的长度，搜索时不需要处理。
5. varchar 并不是设置的越大越好，请设置合理的长度，因为它虽然是变长的，设置的较大时不会占用资盘空间，但是搜索时 varchar 在内存中通常分配设置的大小的内存快来保存，例如排序时 varchar 就是按照设置的长度进行的，所以要设置合理的长度。

### TEXT 和 BLOB
TEXT 类型类似于 CHAR（0-255 字节）和 VARCHAR（0-65,535 字节），但可以存储更长的字符串，即长文本数据。  
TINYTEXT(0-255) / TEXT(0-65535)  / MEDIUMTEXT(0-16MB) / LONGTEXT(0-4GB)  

BLOB 存储二进制字符串，长度和 TEXT 差不多。

但是不建议使用：
1. 不能有默认值
2. 无法使用内存临时表
3. 只能使用前缀索引
4. 消耗大量网络IO
5. DML 可能变慢

并不是不允许存储这两种内容的字段，如果真的需要可以单独建表存储，如果内容过大，还是建议使用对象存储。

### 不建议使用 NULL
1. 不能使用 = 判断，只能使用 is NULL \ is not NULL  
2. 值不确定， select NULL = NULL 结果为 false;
3. 聚合函数会忽略 NULL
4. Count 函数如果 count(*) 会统计到 NULL 的行，如果 count(列) 则统计不到 NULL 的行，导致结果不一致。
5. '' 不占用空间， NULL 反而占用空间。

### DATETIME&TIMESTAMP
DATETIME 类型没有时区信息，TIMESTAMP 和时区有关。  
TIMESTAMP 需要 4 个字节的存储，DATETIME 需要 8 个字节。  
Timestamp 表示的时间范围更小：1970-01-01 00:00:01 ~ 2037-12-31 23:59:59。 DATETIME：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59  

## MySQL 存储引擎
5.5 之前默认是 MyISAM 5.5 之后是 InnoDB。现在几乎都是使用 InnoDB
两者的区别：
1. 是否支持事务。
2. 是否支持表锁。
3. 是否支持外键。
4. 是否支持 MVCC。
5. 是否支持数据恢复。  
毫无疑问：上边几种 InnoDB 支持 MyISAM 都不支持。

## MySQL 事务
### 事务即 ACID 
1. 原子性（Atomicity)
2. 一致性（Consistency)
3. 隔离性（Isolation)
4. 持久性（Durabiltiy)
其实 AID -> C

### 事务并发的问题
1. 脏读，一个事务读到了另一个事物未提交的数据。
2. 修饰修改，两个事务并发执行，后提交的事务覆盖了前提交的事务的结果。
3. 不可重复读，一个事务读取数据，读取到的两次数据不一致。
4. 幻读，一个事务读取数据，读取到的两次数据条数不一致。

> 其实解决事务并发问题就两种:
>- 锁
>- MVCC

### MySQL 事务隔离级别
- read-uncommited 读未提交
- read-commited 读已提交 （解决脏读问题）
- repeateble-read 可重复读 （解决脏读、不可重复读）（默认的）
- serializable 串行化 （解决所有事务并发问题）

## MySQL 的锁
### MySQL的锁按照控制方式分为 **共享锁（S）** 和 **排他锁（X）**。
1. 共享锁： 读锁，允许事务读取记录时获取共享锁，允许多个事务同时获取。
2. 排他锁： 写锁/独占锁，事务独占。
> 普通 select 不会加任何锁，   
> select .. for share -- 加共享锁   
> select .. for update -- 加排他锁  
> 表级锁和行级锁，都支持共享锁和排他锁。

###  按照锁的粒度，MySQL的锁又分为 **表级锁** 和 **行级锁**。
行级锁又分为：
- 记录锁(record lock)，仅锁单行记录
- 间隙锁（gap lock)，锁定一个范围，不包括记录本身
- 临键锁（next-key lock), 记录锁+间隙锁，锁定一个范围，包含记录本书，主要是为了解决 RR 事务隔离级别下幻读的问题。
> RR 事务隔离级别默认使用 Next-key lock 但是操作的索引是唯一索引或者主键，InnoBD 会把 Next-key lock 降级成 Record lock。

### 意向锁
意向锁只有表锁，它的用途就是为了快速判断是否可以加表锁。意向锁是 Mysql 控制的，我们写程序无法控制。  
> 例如某个事务需要加表锁，但是它去判断某个行是否有行锁，效率就特别低，所以 Mysql 增加了意向锁。  
> 我们需要给数据库某些行增加锁，要先获得相应的意向锁，这样事务再去加表锁的时候，只需要判断意向锁即可。

### MVCC 多版本并发控制
一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。  
通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。  
MVCC 在 MySQL 中实现所依赖的手段主要是: 
- 隐藏字段（TXID）
- read view
- undo log

undo log : undo log 用于记录某行数据的多个版本的数据。  
read view 和 隐藏字段 : 用来判断当前版本数据的可见性。  

### 当前读和快照读

## 索引
索引是一种数据结构，它能够帮助数据库快速查找表中的数据。通过索引，可以大大减少数据库需要扫描的行数，从而加速查询操作。
> 你可以将索引理解为一本书的目录，它帮助你快速找到你需要的信息，而不必逐页翻找。

### MySQL 索引的类型
MySQL 支持多种类型的索引，每种索引都有其独特的功能和适用场景：

1. B+Tree 索引：  
最常用的索引类型，适用于大多数场景。支持精确匹配、范围查找和部分匹配。

2. 哈希索引：
通过键的哈希值直接定位数据行，速度极快。适合精确匹配查询。不支持范围查询，效率较低。
   - **适用场景**：适用于仅需精确匹配的场景，例如缓存表。

3. **全文索引**：
   - **特点**：用于全文搜索，支持自然语言文本的查找。
   - **优点**：能够快速进行文本内容的复杂搜索。
   - **适用场景**：适用于需要全文检索的应用，如文章、评论等。

4. **空间索引**：
   - **特点**：用于地理空间数据的查询。
   - **优点**：支持多维数据的高效查询。
   - **适用场景**：适用于存储地理信息的应用。

#### 索引的优点

使用索引可以显著提升数据库的查询性能，主要体现在以下几个方面：

1. **加速数据检索**：索引可以大幅减少查询需要扫描的数据量，从而加速数据检索。
2. **减少 I/O 操作**：通过索引，可以减少磁盘 I/O 操作，提高系统响应速度。
3. **提高排序效率**：索引有助于排序操作的高效执行，避免全表扫描。

#### 索引的缺点

尽管索引有很多优点，但它们也有一些需要注意的缺点：

1. **增加存储空间**：每个索引都需要额外的存储空间，特别是对于大表。
2. **降低数据修改效率**：插入、更新和删除操作需要更新索引，可能会降低这些操作的性能。
3. **管理复杂度增加**：创建和维护索引需要一定的管理成本和技术水平。

#### 如何使用 MySQL 索引

在 MySQL 中创建索引非常简单。你可以使用 `CREATE INDEX` 语句或在创建表时指定索引。以下是一些使用索引的建议：

1. **合理选择列**：选择经常用于查询条件或排序的列进行索引。避免在频繁更新的列上创建索引，以免影响性能。
   
   ```sql
   CREATE INDEX idx_user_name ON users(name);
   ```

2. **避免过多索引**：过多的索引会占用大量空间，并影响数据修改操作的性能。一般来说，不同查询可以共享的索引不要重复创建。

3. **定期维护索引**：定期分析和优化索引，清理不再使用的索引，确保数据库保持最佳性能。

#### 示例：创建和使用索引

假设我们有一个包含大量用户数据的表 `users`，我们希望加速对用户名的查询操作：

1. 创建表和插入数据：
   
   ```sql
   CREATE TABLE users (
       id INT AUTO_INCREMENT PRIMARY KEY,
       name VARCHAR(100),
       age INT
   );

   INSERT INTO users (name, age) VALUES ('Alice', 30), ('Bob', 25), ('Charlie', 35);
   ```

2. 创建索引：
   
   ```sql
   CREATE INDEX idx_name ON users(name);
   ```

3. 使用索引查询：
   
   ```sql
   SELECT * FROM users WHERE name = 'Alice';
   ```

使用索引后，MySQL 会在查询时直接使用索引查找匹配的数据行，而不是进行全表扫描，从而大大提升查询速度。