---
title: MySQL进阶3
category:
  - 数据库
order: 4
tag:
  - 数据库
  - mysql
---

## Explain

### 示例
```sql
EXPLAIN SELECT * FROM users WHERE username = 'zhangsan';
```

`EXPLAIN` 的输出如下：

```
+----+-------------+-------+------------+------+---------------+---------+---------+-------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key     | key_len | ref   | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+---------+---------+-------+------+----------+-------------+
|  1 | SIMPLE      | users | NULL       | ref  | idx_username  | idx_username | 102   | const |    1 |   100.00 | Using where |
+----+-------------+-------+------------+------+---------------+---------+---------+-------+------+----------+-------------+
```

- `id`：`1`，表示这个查询是一个简单查询。对于复杂的查询，如带有子查询或联合查询的，`id` 值可能会不同。
- `select_type`：`SIMPLE`，表示这是一个没有子查询的简单查询。
- `table`：`users`，查询的表是 `users`。
- `type`：`ref`，表示使用了索引扫描 * 。
- `possible_keys`：`idx_username`，表示可能使用的索引是 `idx_username`。
- `key`：`idx_username`，实际使用的索引是 `idx_username`。
- `key_len`：`102`，表示索引键的长度是 102 字节。
- `ref`：`const`，表示查询条件是一个常量。
- `rows`：`1`，表示预计扫描 1 行。
- `filtered`：`100.00`，表示过滤条件通过的百分比是 100%。
- `Extra`：`Using where`，表示查询使用了 `WHERE` 条件过滤。

### select_type：`SELECT` 语句的类型，表示查询的类型。常见的类型有：
  - `SIMPLE`：简单查询，不包含子查询或联合查询。
  - `PRIMARY`：主查询，即最外层的查询。
  - `UNION`：`UNION` 操作的第二个或后续的查询。
  - `DEPENDENT UNION`：依赖于外部查询的 `UNION`。
  - `SUBQUERY`：子查询。
  - `DEPENDENT SUBQUERY`：依赖于外部查询的子查询。
  - `DERIVED`：派生表（临时表）。

### type：表访问方式，表示 MySQL 如何查找满足条件的行。访问方式的效率从高到低包括：
  - `system`：系统表，表中只有一行。
  - `const`：常量表，表中最多有一个匹配行。
  - `eq_ref`：唯一索引扫描，对于每个索引键值访问一个表中的一行。
  - `ref`：非唯一索引扫描，返回所有匹配的行。
  - `range`：索引范围扫描。
  - `index`：全索引扫描。
  - `ALL`：全表扫描。

### Extra：额外的信息，描述查询执行的详细情况。常见的值包括：
  - `Using index`：查询使用了覆盖索引。
  - `Using where`：查询使用了 `WHERE` 条件过滤。
  - `Using temporary`：查询使用了临时表。
  - `Using filesort`：查询使用了文件排序，表示需要额外的排序步骤。


### optimizer trace
在`MySQL 5.6`以及之后的版本中，`MySQL`提出了一个`optimizer trace`的功能，这个功能可以让我们方便的查看优化器生成执行计划的整个过程，这个功能的开启与关闭由系统变量`optimizer_trace`决定。
```sql
-- 1. 查看optimizer_trace功能是否开启
SHOW VARIABLES LIKE 'optimizer_trace';
-- 开启 optimizer_trace
SET optimizer_trace="enabled=on";
--  查询语句
SELECT ...; 
-- 从OPTIMIZER_TRACE表中查看上一个查询的优化过程
SELECT * FROM information_schema.OPTIMIZER_TRACE;
-- 不再查看语句的优化过程时，把optimizer trace功能关闭
SET optimizer_trace="enabled=off";
```

## Buffer Pool
在`InnoDB`存储引擎在处理客户端的请求时，需要访问某个页的数据时，就会把完整的页的数据全部加载到内存中，然后就可以进行读写访问了，在进行完读写访问之后并不着急把该页对应的内存空间释放掉，而是将其`缓存`起来，这样将来有请求再次访问该页面时，就可以省去磁盘`IO`的开销了。

- 默认的缓存页大小和在磁盘上默认的页大小是一样的，都是`16KB`。
- 为了缓存磁盘中的页，MySQL服务启动的时候会向系统申请一片连续的区域，这片区域就是 Buffer Pool，可以通过 innodb_buffer_pool_size 控制大小。
- `Buffer Pool`向操作系统申请的连续内存由控制块和缓存页组成，控制块和缓存页是一一对应的，在填充足够多的控制块和缓存页的组合后，`Buffer Pool`剩余的空间可能产生不够填充一组控制块和缓存页，这部分空间不能被使用，也被称为`碎片`。
- 控制块中的控制信息包括该页所属的表空间编号、页号、缓存页在`Buffer Pool`中的地址、链表节点信息、一些锁信息以及`LSN`信息。
- `InnoDB`使用了许多`链表`来管理`Buffer Pool`。
- 把所有空闲的缓存页对应的控制块作为一个节点放到一个链表中，这个链表也可以被称作`free链表`（空闲链表）。刚刚完成初始化的`Buffer Pool`中所有的缓存页都是空闲的，所以每一个缓存页对应的控制块都会被加入到`free链表`中。
- 在将磁盘中的页加载到`Buffer Pool`时，会从`free链表`中寻找空闲的缓存页。
- 为了快速定位某个页是否被加载到`Buffer Pool`，使用`表空间号 + 页号`作为`key`，缓存页作为`value`，建立哈希表。
- 在`Buffer Pool`中被修改的页称为`脏页`，脏页并不是立即刷新，而是被加入到`flush链表`中，待之后的某个时刻同步到磁盘上。
- `LRU链表`分为`young`和`old`两个区域，可以通过`innodb_old_blocks_pct`来调节`old`区域所占的比例。首次从磁盘上加载到`Buffer Pool`的页会被放到`old`区域的头部，在`innodb_old_blocks_time`间隔时间内访问该页不会把它移动到`young`区域头部。在`Buffer Pool`没有可用的空闲缓存页时，会首先淘汰掉`old`区域的一些页。
- 可以设置`Buffer Pool`实例的个数，每个`Buffer Pool`实例中都有各自独立的链表，互不干扰。
- 自`MySQL 5.7.5`版本之后，可以在服务器运行过程中调整`Buffer Pool`大小。每个`Buffer Pool`实例由若干个`chunk`组成，每个`chunk`的大小可以在服务器启动时通过启动参数调整。


## 事务
### 事务的特性
1. 原子性（`Atomicity`）  
事务内的数据库更新，要么全部成功，要么全部失败，没有中间状态。
2. 隔离性（`Isolation`）  
不同的事务直接要互相隔离，不能影响到其他的事务。
3. 一致性（`Consistency`）  
例如多次互相转账，不能导致钱的总额减少或者增多。
4. 持久性（`Durability`）  
当一个状态转换完成后，这个转换的结果将永久的保留。

### 事务的概念
需要保证`ACID（原子性`、`隔离性`、`一致性`、`持久性）`的一个或多个数据库操作称之为一个`事务`（`transaction`）。

### 事务的状态
1. 活动的（active）  
事务对应的数据库操作正在执行过程中。
2. 部分提交的（partially committed）  
事务中最后一个操作执行完成，但操作都在内存中执行，还没有刷新到磁盘。
3. 失败的（failed）  
事务处在`活动的`或者`部分提交的`状态中，因为某些错误无法继续执行，或者人为的停止当前事务的执行。
4. 中止的（aborted）  
事务执行过程中变为`失败的`状态，要撤销失败事务对当前数据库造成的影响。这个撤销的过程称之为`回滚`。当`回滚`操作执行完毕时，该事务处在了`中止的`状态。
5. 提交的（committed）  
`部分提交的`状态的事务将修改过的数据都同步到磁盘上之后，该事务处在了`提交的`状态。

> 只有当事务处于提交的或者中止的状态时，一个事务的生命周期才算是结束了。


### 事务的操作
```sql
-- 开启事务
BEGIN;
-- 开启事务
START TRANSACTION;
-- 开启一个只读事务
START TRANSACTION READ ONLY;
-- 开启一个只读事务和一致性读
START TRANSACTION READ ONLY, WITH CONSISTENT SNAPSHOT;
-- 开启一个读写事务和一致性读
START TRANSACTION READ WRITE, WITH CONSISTENT SNAPSHOT;
-- 提交事务
COMMIT;
-- 回滚事务
ROLLBACK;
```

> MySQL 事务的 autocommit 时开启的，所以我们不手动开启的事务的话，那么每一条语句都算是一个独立的事务，这种特性称之为事务的`自动提交`。  

### 保存点
`保存点`（`savepoint`）就是在事务对应的数据库语句中打几个点，调用`ROLLBACK`语句时可以指定会滚到哪个点，而不是回到最初的原点。
```sql
SAVEPOINT 保存点名称;
ROLLBACK [WORK] TO [SAVEPOINT] 保存点名称;
```

## redo log
### 为什么需要 redo log
`InnoDB`存储引擎是以页为单位来管理存储空间的，在真正访问数据库页之前，需要把在磁盘上的页缓存到内存中的`Buffer Pool`之后才可以访问。  
如果只在内存的`Buffer Pool`中修改了页面，在事务提交后突然发生了某个故障，导致内存中的数据都失效了，那么这个已经提交了的事务对数据库中所做的更改也就跟着丢失了，这就不能保证`持久性`的特性。  
比较容易保证这个`持久性`的做法是在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘上，但是这么实现有几个问题：

1. 刷新一个完整的数据页太浪费了  
比如仅修改了某个页面中的一个字节，就要刷新 16KB 的数据到磁盘上。
2. 随机IO刷起来比较慢  
一个事务可能修改许多页面，这就意味着在将某个事务修改的`Buffer Pool`中的页面刷新到磁盘时，需要进行很多的随机IO，这是很慢的。

持久性只需要保证已经提交了的事务对数据库中数据所做的修改永久生效，完全没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把修改了哪些东西记录一下就好了，这个记录就是 redo log。  
而且`redo`日志占用的空间非常小，`redo`日志还是顺序写入磁盘的。

### redo log 格式
- `type`：该条`redo`日志的类型。  
在`MySQL 5.7.21`这个版本中，共有 53 种不同的类型。
- `space ID`：表空间ID。
- `page number`：页号。
- `data`：该条`redo`日志的具体内容。

### redo log 的刷盘
redo log 的写入也是在内存中，但是为了保证持久性，redo log 是需要经常性刷盘的。有以下几个刷屏时机：
1. `log buffer`空间不足时  
redo log 志量已经占满了`log buffer`总容量的大约一半左右，就需要把这些日志刷新到磁盘上。
2. 事务提交时  
我们前面说过之所以使用`redo`日志主要是因为它占用的空间少，还是顺序写，在事务提交时可以不把修改过的`Buffer Pool`页面刷新到磁盘，但是为了保证持久性，必须要把修改这些页面对应的`redo`日志刷新到磁盘。
3. 后台线程不停的刷  
后台有一个线程，大约每秒都会刷新一次`log buffer`中的`redo`日志到磁盘。
4. 正常关闭服务器时  
5. 做`checkpoint`时  
6. 其他的一些情况...  

## undo log
### 为什么需要 undo log
每当我们要对一条记录做改动时，都需要把回滚时用到的东西都给记下来。
1. 插入一条记录，要把这条记录的主键值记下来，回滚的时候把这个主键值对应的记录删掉。
2. 删除了一条记录，要把这条记录中的内容都记下来，回滚时再把这些内容插入到表中。
3. 修改了一条记录，要把修改这条记录前的旧值都记录下来，回滚时再把这条记录更新为旧值。  

这些为了回滚而记录的日志称之为`undo log`。

### 事务id&roll_pointer
某个事务执行过程中对某个表执行了增、删、改操作，那么`InnoDB`存储引擎就会给它分配一个独一无二的`事务id`。  
`InnoDB`记录行格式中，聚簇索引的记录除了会保存完整的用户数据以外，而且还会自动添加名为trx_id、roll_pointer的隐藏列，如果用户没有在表中定义主键以及 UNIQUE 键，还会自动添加一个名为 row_id 的隐藏列。  
其中的`trx_id`列其实就是某个对这个聚簇索引记录做改动的语句所在的事务对应的`事务id`。  
而`roll_pointer`本质就是一个指针，它指向记录对应的undo日志。  

## MVCC
我们知道数据有个 ACID 四个特性，如果完全遵守这四个特性，可能就需要让各个事务串行执行，这样性能是很差的，所以mysql事务就舍弃了一部分隔离性，来保证性能。

### 事务并发的问题
1. 脏写(丢失更新)：一个事务修改了另一个未提交事务的数据
2. 脏读：一个事务读到了另一个未提交事务修改过的数据
3. 不可重复读：一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值。
4. 幻读：一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来

### 事务隔离级别
数据库通过事务隔离级别来控制这些并发问题：
| 隔离级别 | 脏读 | 不可重复读 | 幻读 | 使用场景 |
| --- | --- | --- | --- | --- |
| 读未提交 (Read Uncommitted) | 允许 | 允许 | 允许 | 性能优先 |
| 读已提交 (Read Committed) | 禁止 | 允许 | 允许 | 大部分数据库默认 |
| 可重复读 (Repeatable Read) | 禁止 | 禁止 | 允许 | MySQL 默认 |
| 串行化 (Serializable) | 禁止 | 禁止 | 禁止 | 严格一致性 |
> 这是因为脏写（丢失更改 lost update）这个问题太严重了，不论是哪种隔离级别，都不允许脏写的情况发生。

### MVCC 原理
#### 版本链
对于使用`InnoDB`存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列。
- `trx_id`：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的`事务id`赋值给`trx_id`隐藏列。
- `roll_pointer`：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到`undo日志`中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。

每次对记录进行改动，都会记录一条`undo日志`，每条`undo日志`也都有一个`roll_pointer`属性，可以将这些`undo日志`都连起来，串成一个链表，对该记录每次更新后，都会将旧值放到一条`undo日志`中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被`roll_pointer`属性连接成一个链表，我们把这个链表称之为`版本链`。  
版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的`事务id`。

#### ReadView
对于使用`读未提交（READ UNCOMMITTED）`隔离级别的事务来说，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本。  
对于使用`串行（SERIALIZABLE）`隔离级别的事务来说，使用加锁的方式来访问记录。  

而对于使用`读已提交（READ COMMITTED）`和`可重复读（REPEATABLE READ）`隔离级别的事务来说，都必须保证读到已经提交了的事务修改过的记录，也就是说假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的。  
核心问题就是：需要判断一下版本链中的哪个版本是当前事务可见的。为此，`InnoDB`提出了一个`ReadView`的概念，这个`ReadView`中主要包含4个比较重要的内容：
1. `m_ids`：表示在生成`ReadView`时当前系统中活跃的读写事务的`事务id`列表。
2. `min_trx_id`：表示在生成`ReadView`时当前系统中活跃的读写事务中最小的`事务id`，也就是`m_ids`中的最小值。
3. `max_trx_id`：表示生成`ReadView`时系统中应该分配给下一个事务的`id`值。
> 注意： max_trx_id 并不是 m_ids 中的最大值，事务 id 是递增分配的。  
> 比方说现在有 id 为 1，2，3 这三个事务，之后 id 为 3 的事务提交了。  
> 那么一个新的读事务在生成 ReadView 时，m_ids 就包括 1 和 2，min_trx_id的值就是1，max_trx_id的值就是4。
4. `creator_trx_id`：表示生成该`ReadView`的事务的`事务id`。
> 只有在对表中的记录做改动时才会为事务分配事务id，在一个只读事务中的事务 id 值都默认为 0。

有了这个`ReadView`，再访问某条记录时，只需要按照下面的步骤判断记录的某个版本是否可见：
1. 如果被访问版本的`trx_id`属性值与`ReadView`中的`creator_trx_id`值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。
2. 如果被访问版本的`trx_id`属性值小于`ReadView`中的`min_trx_id`值，表明生成该版本的事务在当前事务生成`ReadView`前已经提交，所以该版本可以被当前事务访问。
3. 如果被访问版本的`trx_id`属性值大于`ReadView`中的`max_trx_id`值，表明生成该版本的事务在当前事务生成`ReadView`后才开启，所以该版本不可以被当前事务访问。
4. 如果被访问版本的`trx_id`属性值在`ReadView`的`min_trx_id`和`max_trx_id`之间，那就需要判断一下`trx_id`属性值是不是在`m_ids`列表中，如果在，说明创建`ReadView`时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建`ReadView`时生成该版本的事务已经被提交，该版本可以被访问。

如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上面的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。

在`MySQL`中，`READ COMMITTED`和`REPEATABLE READ`隔离级别的的一个非常大的区别就是它们生成 ReadView 的时机不同。
+ READ COMMITTED ，每次读取数据前都生成一个ReadView
+ REPEATABLE READ ， 在第一次读取数据时生成一个ReadView，之后的查询操作都重复使用这个 ReadView。

> 正是因为第一次在事务中读取数据只会创建一个 ReadView 所以在一个事务中多次读取数据，就保证了不可重复读的问题。

### 总结
`MVCC`（Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用 `READ COMMITTD`、`REPEATABLE READ` 这两种隔离级别的事务在执行普通的`SEELCT`操作时访问记录的版本链的过程，这样子可以使不同事务的`读-写`、`写-读`操作并发执行，从而提升系统性能。  
`READ COMMITTD`、`REPEATABLE READ`这两个隔离级别的一个很大不同就是：生成ReadView 的时机不同，READ COMMITTD 在每一次进行普通 SELECT 操作前都会生成一个 ReadView，而 REPEATABLE READ 只在第一次进行普通 SELECT 操作前生成一个 ReadView，之后的查询操作都重复使用这个ReadView 就好了。

## 锁
### MySQL的事务并发
MySQL的事务并发的情况有以下几种：
1. `读-读`情况：即并发事务相继读取相同的记录。  
读取操作本身不会对记录有影响，并不会引起什么问题，所以允许这种情况的发生。
2. `写-写`情况：即并发事务相继对相同的记录做出改动。  
这种情况下会发生`脏写`的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们排队执行，这个排队的过程是通过`锁`来实现的。

> 这个所谓的`锁`其实是一个内存中的结构，在事务执行前本来是没有锁的，一开始是没有`锁结构`和记录进行关联的。
> 当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的`锁结构`，当没有的时候就会在内存中生成一个`锁结构`与之关联。比方说事务`T1`要对这条记录做改动，就需要生成一个`锁结构`与之关联。

> 在`锁结构`里有两个比较重要的属性：
> + `trx信息`：代表这个锁结构是哪个事务生成的。
> + `is_waiting`：代表当前事务是否在等待。

> 当一个事务改动了这条记录后，就生成了一个`锁结构`与该记录关联，因为之前没有别的事务为这条记录加锁，所以`is_waiting`属性就是`false`，我们把这个场景就称之为获取锁成功，或者加锁成功，然后就可以继续执行操作了。  
> 在一个事务提交之前，另一个事务想对该记录做改动，就要先查看有没有`锁结构`与这条记录关联，发现有一个`锁结构`与之关联后，也生成了一个`锁结构`与这条记录关联，不过`锁结构`的`is_waiting`属性值为`true`，表示当前事务需要等待，我们把这个场景就称之为获取锁失败，或者加锁失败，或者没有成功的获取到锁。  
> 在前一个事务提交之后，就会把该事务生成的`锁结构`释放掉，然后看看还有没有别的事务在等待获取锁，发现了另一个事务还在等待获取锁，就把该事务对应的锁结构的`is_waiting`属性设置为`false`，然后把该事务对应的线程唤醒，让它继续执行，此时事务`T2`就算获取到锁了。


3. `读-写`或`写-读`情况：也就是一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生`脏读`、`不可重复读`、`幻读`的问题。   
解决`脏读`、`不可重复读`、`幻读`这些问题，有两种可选的解决方案：
    + 方案一：读操作利用多版本并发控制（`MVCC`），写操作进行`加锁`。
    + 方案二：读、写操作都采用`加锁`的方式。
> 如果业务场景不允许读取记录的旧版本，每次都必须去读取记录的最新版本，在银行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额，最后再写到数据库中。  
> 在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其他事务才可以访问账户的余额。这样在读取记录的时候也就需要对其进行`加锁`操作，这样也就意味着`读`操作和`写`操作也像`写-写`操作那样排队执行。  

> 采用`MVCC`方式的话，`读-写`操作彼此并不冲突，性能更高，采用`加锁`方式的话，`读-写`操作彼此需要排队执行，影响性能。一般情况下采用`MVCC`来解决`读-写`操作并发执行的问题更好，但是业务在某些特殊情况下，要求必须采用`加锁`的方式执行。

### 一致性读（Consistent Reads）
事务利用`MVCC`进行的读取操作称之为`一致性读`，或者`一致性无锁读`、`快照读`。所有普通的 `SELECT` 语句在 `READ COMMITTED`、`REPEATABLE READ`隔离级别下都算是 `一致性读`。
```sql
SELECT * FROM table_name;
```
> `一致性读`并不会对表中的任何记录做`加锁`操作，其他事务可以自由的对表中的记录做改动。

### 锁定读（Locking Reads）
加共享锁（s锁）
```sql
SELECT ... LOCK IN SHARE MODE;
```
加排他锁（x锁）
```sql
SELECT ... FOR UPDATE;
```

### 写操作
平常所用到的`写操作`无非是`DELETE`、`UPDATE`、`INSERT`这三种：
+ `DELETE`：  
先在`B+`树中定位到这条记录的位置，然后获取一下这条记录的`X锁`，然后再执行`delete mark`操作。我们也可以把这个定位待删除记录在`B+`树中位置的过程看成是一个获取`X锁`的`锁定读`。
+ `UPDATE`：  
在对一条记录做`UPDATE`操作时分为三种情况：

    - 如果未修改该记录的键值并且被更新的列占用的存储空间在修改前后未发生变化，则先在`B+`树中定位到这条记录的位置，然后再获取一下记录的`X锁`，最后在原记录的位置进行修改操作。其实我们也可以把这个定位待修改记录在`B+`树中位置的过程看成是一个获取`X锁`的`锁定读`。 
    - 如果未修改该记录的键值并且至少有一个被更新的列占用的存储空间在修改前后发生变化，则先在`B+`树中定位到这条记录的位置，然后获取一下记录的`X锁`，将该记录彻底删除掉（就是把记录彻底移入垃圾链表），最后再插入一条新记录。这个定位待修改记录在`B+`树中位置的过程看成是一个获取`X锁`的`锁定读`，新插入的记录由`INSERT`操作提供的`隐式锁`进行保护。
    - 如果修改了该记录的键值，则相当于在原记录上做`DELETE`操作之后再来一次`INSERT`操作，加锁操作就需要按照`DELETE`和`INSERT`的规则进行了。
+ `INSERT`：  
一般情况下，新插入一条记录的操作并不加锁，`InnoDB`通过`隐式锁`的来保护这条新插入的记录在本事务提交前不被别的事务访问。

### 多粒度锁
表级X锁，表级S锁，行级X锁，行级S锁，表级别的意向锁IS，表级别的意向锁IX。
> IS，意向共享锁，IX，意向排他锁。  
> 其实就是加行级锁的时候要先加表级的意向锁，这样再加表级的锁，不用挨着去遍历表中的行，看看有没有那个行上有锁了，这样加表级锁的时候看到有意向锁，说明表内部有行锁。
>

| 兼容性 | `X` | `IX` | `S` | `IS` |
| --- | --- | --- | --- | --- |
| `X` | 不兼容 | 不兼容 | 不兼容 | 不兼容 |
| `IX` | 不兼容 | 兼容 | 不兼容 | 兼容 |
| `S` | 不兼容 | 不兼容 | 兼容 | 兼容 |
| `IS` | 不兼容 | 兼容 | 兼容 | 兼容 |


### InnoDB 表级锁
1. 表级别的`S锁`、`X锁`  
在对某个表执行`SELECT`、`INSERT`、`DELETE`、`UPDATE`语句时，`InnoDB`存储引擎是不会为这个表添加表级别的`S锁`或者`X锁`的。  
只有在对某个表执行一些诸如`ALTER TABLE`、`DROP TABLE`这类的`DDL`语句时，其他事务对这个表并发执行的语句会发生阻塞，同理，某个事务中对某个表执行`SELECT`、`INSERT`、`DELETE`、`UPDATE`语句时，在其他会话中对这个表执行`DDL`语句也会发生阻塞。  
这个过程是通过在`server层`的`元数据锁`（`Metadata Locks`）来实现的，一般情况下不会使用`InnoDB`存储引擎自己提供的表级别的`S锁`和`X锁`。  
> `InnoDB`存储引擎提供的表级`S锁`或者`X锁`是相当鸡肋，只会在一些特殊情况下，比方说崩溃恢复过程中用到。`InnoDB`的厉害之处还是实现了更细粒度的行锁，关于表级别的`S锁`和`X锁`了解一下。

2. 表级别的`IS锁`、`IX锁`  
在对表的某些记录加`S锁`之前，需要先在表级别加一个`IS锁`，在对表的某些记录加`X锁`之前，那就需要先在表级别加一个`IX锁`。  
`IS锁`和`IX锁`的使命只是为了后续在加表级别的`S锁`和`X锁`时判断表中是否有已经被加锁的记录，以避免用遍历的方式来查看表中有没有上锁的记录。  

3. 表级别的`AUTO-INC锁`  
在使用`MySQL`过程中，我们可以为表的某个列添加`AUTO_INCREMENT`属性，之后在插入记录时，可以不指定该列的值，系统会自动为它赋上递增的值，系统实现这种自动给`AUTO_INCREMENT`修饰的列递增赋值的原理主要是两个：  
    - 采用`AUTO-INC`锁  
    也就是在执行插入语句时就在表级别加一个`AUTO-INC`锁，然后为每条待插入记录的`AUTO_INCREMENT`修饰的列分配递增的值，在该语句执行结束后，再把`AUTO-INC`锁释放掉。这样一个事务在持有`AUTO-INC`锁的过程中，其他事务的插入语句都要被阻塞，可以保证一个语句中分配的递增值是连续的。
    - 采用一个轻量级的锁  
    在为插入语句生成`AUTO_INCREMENT`修饰的列的值时获取一下这个轻量级锁，然后生成本次插入语句需要用到的`AUTO_INCREMENT`列的值之后，就把该轻量级锁释放掉，并不需要等到整个插入语句执行完才释放锁。

### InnoDB中的行级锁
`行锁`，也称为`记录锁`，就是在记录上加的锁。

#### Record Lock  
记录锁就是这种类型，也就是仅仅把一条记录锁上官方称为：`LOCK_REC_NOT_GAP`。  
`record lock`是有`S锁`和`X锁`之分的，当一个事务获取了一条记录的`S锁`后，其他事务也可以继续获取该记录的`S锁`，但不可以继续获取`X锁`；当一个事务获取了一条记录的`X锁`后，其他事务既不可以继续获取该记录的`S锁`，也不可以继续获取`X锁`；

#### Gap Locks
`MySQL`在 `REPEATABLE READ` 隔离级别下是可以解决幻读问题的，解决方案有两种，1. 可以使用`MVCC`方案解决，2. 可以采用`加锁`方案解决。  
但是在使用`加锁`方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些幻影记录加上 Record lock。`Gap Locks`就是解决这个问题的。

例如我给 `col=8` 的记录加了`gap锁`，意味着不允许别的事务在 `col` 值为 `8` 的记录前面的 `间隙` 插入新记录，就是 col 列的值 `(8的前一个记录, 8)` 这个区间的新记录是不允许立即插入的。直到拥有这个`gap锁`的事务提交了之后，`col`列的值在区间`(8的前一个记录, 8)`中的新记录才可以被插入。

这个`gap锁`的提出仅仅是为了防止插入幻影记录而提出的，`共享gap锁`和`独占gap锁`起到的作用都是相同的。而且如果你对一条记录加了`gap锁`（不论是`共享gap锁`还是`独占gap锁`），并不会限制其他事务对这条记录加`Record Lock`或者继续加`gap锁`。

> 强调，`gap锁`的作用仅仅是为了防止插入幻影记录的而已。

给一条记录加了`gap锁`不允许其他事务往这条记录前面的间隙插入新记录，那么给哪条记录加 `gap锁` 才能阻止其他事务插入`col`值在`(最大, +∞)`这个区间的新记录呢？这时候需要`数据页`的两条伪记录了：
+ `Infimum`记录，表示该页面中最小的记录。
+ `Supremum`记录，表示该页面中最大的记录。  

为了实现阻止其他事务插入`col`值在`(最大值, +∞)`这个区间的新记录，我们可以给索引中的最后一条记录，也就是`col`值为`最大`的那条记录所在页面的`Supremum`记录加上一个`gap锁`，这样就可以阻止其他事务插入`col`值在`(最大记录, +∞)`这个区间的新记录。

#### Next-Key Locks
有时候我们既想锁住某条记录，又想阻止其他事务在该记录前面的`间隙`插入新记录，所以设计`InnoDB`的大佬们就提出了一种称之为`Next-Key Locks`的锁，官方的类型名称为：`LOCK_ORDINARY`，我们也可以简称为`next-key锁`。

`next-key锁`的本质就是一个`行锁`和一个`gap锁`的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前面的`间隙`。

#### 插入意向锁 `Insert Intention Locks`：

一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了所谓的`gap锁`（`next-key锁`也包含`gap锁`），如果有的话，插入操作需要等待，直到拥有`gap锁`的那个事务提交。`InnoDB`的事务在等待的时候也需要在内存中生成一个`锁结构`，表明有事务想在某个`间隙`中插入新记录，但是现在在等待。
这种类型的锁命就是`Insert Intention Locks`，官方的类型名称为：`LOCK_INSERT_INTENTION`，即`插入意向锁`。

#### 隐式锁

一个事务在执行`INSERT`操作时，如果即将插入的`间隙`已经被其他事务加了`gap锁`，那么本次`INSERT`操作会阻塞，并且当前事务会在该间隙上加一个`插入意向锁`，否则一般情况下`INSERT`操作是不加锁的。  

- 那如果一个事务首先插入了一条记录（此时并没有与该记录关联的锁结构），然后另一个事务立即使用`SELECT ... LOCK IN SHARE MODE`语句读取这条事务，也就是在要获取这条记录的`S锁`，或者使用`SELECT ... FOR UPDATE`语句读取这条事务或者直接修改这条记录，也就是要获取这条记录的`X锁`，该咋办？  
如果允许这种情况的发生，那么可能产生`脏读`问题。  

- 立即修改这条记录，也就是要获取这条记录的`X锁`，该咋办？如果允许这种情况的发生，那么可能产生`脏写`问题。

这时候 `事务id` 又要起作用了。把聚簇索引和二级索引中的记录分开看一下：

    - 情景一：对于聚簇索引记录来说，有一个`trx_id`隐藏列，该隐藏列记录着最后改动该记录的`事务id`。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的`trx_id`隐藏列代表的的就是当前事务的`事务id`，如果其他事务此时想对该记录添加`S锁`或者`X锁`时，首先会看一下该记录的`trx_id`隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个`X锁`（也就是为当前事务创建一个锁结构，`is_waiting`属性是`false`），然后自己进入等待状态（也就是为自己也创建一个锁结构，`is_waiting`属性是`true`）。
    - 情景二：对于二级索引记录来说，本身并没有`trx_id`隐藏列，但是在二级索引页面的`Page Header`部分有一个`PAGE_MAX_TRX_ID`属性，该属性代表对该页面做改动的最大的`事务id`，如果`PAGE_MAX_TRX_ID`属性值小于当前最小的活跃`事务id`，那么说明对该页面做修改的事务都已经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记录，然后再重复`情景一`的做法。

通过上面的叙述我们知道，一个事务对新插入的记录可以不显式的加锁（生成一个锁结构），但是由于`事务id`的存在，相当于加了一个`隐式锁`。别的事务在对这条记录加`S锁`或者`X锁`时，由于`隐式锁`的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态。




## 参考
[深入理解 Mysql 索引底层原理](https://zhuanlan.zhihu.com/p/113917726)  
[next-key锁定范围](https://segmentfault.com/a/1190000040129107)  
[索引之道](https://juejin.cn/post/7161964571853815822)  
[MySQL 是怎样运行的：从根儿上理解 MySQL](https://relph1119.github.io/mysql-learning-notes/#/)
[两万字详解InnoDB的锁](https://juejin.cn/post/7094049650428084232)