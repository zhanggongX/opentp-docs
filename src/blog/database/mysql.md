---
title: MySQL进阶
category:
  - 数据库
order: 2
tag:
  - 数据库
  - mysql
---

## InnoDB 存储引擎
mysql 数据库有很多种数据引擎，例如 MyISAM 和 InnoDB，为了支持事务，目前最常用的是 InnoDB 存储引擎。

## InnoDB 的数据存储
InnoDB 是以页的形式存储数据的，InnoDB 将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 16 KB。也就是在一般情况下，一次最少从磁盘中读取 16KB 的内容到内存中，一次最少把内存中的 16KB 内容刷新到磁盘中。

## InnoDB 的行格式
InnoDB 支持四种行格式分别是 Compact、Redundant、Dynamic 和 Compressed。
所谓的行格式，就是在 InnoDB 中存储一条数据的具体格式，也称为纪录格式。
```sql
-- 设置行格式
CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称
ALTER TABLE 表名 ROW_FORMAT=行格式名称
```
### Compact 行格式
![行格式-图源：MySQL是怎样运行的](images/compact.png)
compact 行格式分为纪录的额外信息和纪录的真实数据。

#### 纪录的额外信息
1. 变长字段的`长度`列表：  
纪录数据行中所有变长字段(varchar, text, blob等)的长度，按照字段的顺序的逆序存储。例如 col1 = varchar(10)，实际长度 3，col2 = varchar(20)，实际长度 4，那么此处存放的是 4，3 的二进制编码。  
```text
至于此处存放长度 `4`，`3` 的具体字段长度则使用以下规则计算：  
W = 字符的最大长度，utf8 = 3, utf8mb4 = 4。
M = 变成字段的最大长度，varchar(10), M = 10。
L = 实际存储的字段长度，例如 varchar(10)，实际长度 3，那么 L = 3。

那么每个长度使用的字节长度 len 计算公式如下：
if(M * W <= 255){
    len = 1;
}else if(M * W > 255){
    if(L <= 127) {
        len = 1;
    }else{
        l == 2;
    }
}
```
> **PS1**: 变长字段存储的值`不为 null`，才会在变长字段长度列表有值。  
> **PS2**: 并不是所有记录都有 `变长字段长度列表` 部分，如果表中所有的列都不是变长的数据类型，这一部分就不需要有。  
> **PS3**: 对于 char(x) 类型的列来说，当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表，而如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表。例如 utf8，char(8) 这一列不为 null，长度也在变成字段长度列表中。

2. null 值列表  
表中所有可以为 null 的字段都会映射成一位在 null 值列表中。  
按照列的逆序存储。  
根据可以为 null 的字段数，决定位数，例如 7 个可以为 null 的字段，那么 null 值列表长度为 1 个字节，如果 12 个可以为空的字段，那么 null 值列表长度为 2 个字节。必须占有整个字节，不足的在高位补 0。  
按照***逆序***，对应的字段的值为 null，则该位为 1，如果该位对象的字段值不是 null，则该位为 0。
```sql
c1 varchar null,
c2 varchar null, 值为 "hello"
c3 varchar not null;

                c3 c2 c1
null 列表 0000 0 1  0  1
null 列表存储的就是 0x05
```

3. 纪录头信息
纪录头信息共 5 个字节，40 位，如下图。
![纪录头-图源：MySQL是怎样运行的](images/record_head.png)

| 名称            | 大小（单位：bit） | 描述                                                         |
|-----------------|------------------|------------------------------------------------------------|
| **预留位1**     | 1                | 没有使用，可能用于未来扩展功能或保留特定位置信息。               |
| **预留位2**     | 1                | 没有使用，与预留位1类似，用于扩展功能或特定位置信息保留。          |
| **delete_mask** | 1                | 标记该记录是否被删除，1表示记录已被删除，0表示记录有效。          |
| **min_rec_mask**| 1                | B+树中，每层非叶子节点的最小记录都会带有该标记，便于树的层次结构管理。 |
| **n_owned**     | 4                | 表示当前记录拥有的记录数，主要用于计算记录分布和空间管理。          |
| **heap_no**     | 13               | 当前记录在记录堆中的位置信息，用于快速索引和定位。                |
| **record_type** | 3                | 表示记录类型：**0**：普通记录，**1**：B+树非叶子节点记录，**2**：最小记录，**3**：最大记录  |
| **next_record** | 16               | 当前记录与下一条记录的相对位置，用于记录链的维护和遍历。           |

```text
纪录头信息详解：
delete_mask：标记当前纪录是否被删除，1 = 已删除，所有的被删除的记录会组成一个垃圾链表，
这种已删除的记录称为可重用空间，如果有新记录，可能会覆盖掉某条 delete_mask = 1 的记录。

min_rec_mask：标记在 B+ 树中，是否是当前层级最小的非叶子节点，如果是则该标记 = 1。

n_owned：表示当前记录拥有的记录数，主要用于计算记录分布和空间管理。

heap_no：表示当前记录在本页中的位置。从 2 开始计数，因为每个页都有两个虚拟记录，
分别是最小记录和最大记录， 0 = 最小记录，1 = 最大记录，最大记录最小记录的值是固定的，分别是 infimun 和 supremum。
这两个记录存放在页中 user_records 位置之前。

record_type: 当前记录的类型，具体见上表。

next_record：表示当前记录的真实数据到下一条记录的真实数据的地址偏移量。
例如 next_recode = 10，那么从第一条记录的真实地址往后找 10 个字节，就是下一条记录的真实数据。
这里的下一条记录并不是插入的下一条记录，而是通过主键排序后的下一条记录，而且是 infimun -> 1 -> 2 -> 3 -> supremum;
```

#### 纪录的真实数据
纪录的真实数据除了数据外，还有一些隐藏字段。
| 列名             | 是否必须 | 占用空间 | 描述                     |
|------------------|----------|----------|--------------------------|
| **row_id**(DB_ROW_ID)       | 否       | 6字节    | 行ID，唯一标识一条记录     |
| **transaction_id**(DB_TRX_ID) | 是       | 6字节    | 事务ID                   |
| **roll_pointer**(DB_ROLL_PTR)  | 是       | 7字节    | 回滚指针                 |

其中 row_id 不是必须的，如果定义的数据表没有指定主键，则会添加一个隐藏的 row_id 作为主键。  
transaction_id 和 roll_pointer 则是 InnoDB 引擎中所有纪录都有的隐藏字段。

### Redundant行格式
Redundant 行格式是 MySQL5.0 之前用的一种行格式，忽略。

### Dynamic行格式
MySQL5.7 版本引入的 Dynamic 行格式是 compact 格式的升级版本。它延续了 compact 格式的优势，在处理大型可变长度列时更具灵活性，能够灵活选择将数据存储在页内还是页外。 Dynamic 格式适用于多数应用场景，在存储空间和性能之间取得了一定的平衡。其结构与 compact 格式大致相似。

与 compact 行格式不同之处在行溢出的处理，dynamic 不会在记录的真实数据处存储字段真实数据的前 768 个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址。

### Compressed行格式
Compressed 行格式在 MySQL5.1 中被 InnoDB 引入，它提供了压缩功能能够减小数据在磁盘上的占用空间，其缺点在于增加了 CPU 的负担，可能导致部分查询性能下降。
Compressed 行格式在 Dynamic 行格式的基础上引入了页外压缩功能。在存储数据时，如果发现可以通过压缩来减小存储空间，系统将选择压缩方式来存储数据。在查询时，数据将会被自动解压并返回结果。

### 行溢出
mysql 限制了一行数据除了 TEXT，BLOB，最多占用 65535 字节空间，这个 65535 除了列本身的数据，还有一些额外的数据，例如 varchar(x) 除了真实数据，还有占用字节长度，NULL 标识等。  

如果 varchar(x) 类型的列使用的不是 ascii 字符集，那 x 的最大取值取决于该字符集表示一个字符最多需要的字节数。在列的值允许为 NULL 的情况下，gbk 字符集表示一个字符最多需要 2 个字节，那在该字符集下，x 的最大取值就是32766（也就是：65532/2），也就是说最多能存储 32766 个字符；utf8 字符集表示一个字符最多需要 3 个字节，那在该字符集下，x 的最大取值就是 21844，就是说最多能存储 21844（也就是：65532/3）个字符。

在 Compact 和 Reduntant 行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据（前 768 字节），把剩余的数据分散存储在几个其他的页中，然后记录的真实数据处用 20 个字节存储指向这些页的地址，从而可以找到剩余数据所在的页。

MySQL 规定一个页至少存放 2 条纪录，没个页需要额外的信息是 127 个字节，每条纪录需要额外的信息是 27 个字节，所以 136 + 2(27 + n) > 16384, n = 8098。如果表只有一个 varchar 字段，字段存放 8098 个字节的内容，就会发生行溢出。

## InnoDB 的页
InnoDB 有很多中页，Insert Buffer 页，undo 日志页等等，存放表数据的页称为索引页(index)，也称为数据页。  
数据页的结构：  
![索引页结构-图源：MySQL是怎么运行的](images/index_page.png)

| 名称                  | 中文名           | 占用空间大小 | 简单描述                        |
|-----------------------|------------------|--------------|---------------------------------|
| **File Header**       | 文件头部         | 38字节       | 页的一些通用信息                 |
| **Page Header**       | 页面头部         | 56字节       | 数据页专有的一些信息             |
| **Infimum + Supremum**| 最小记录和最大记录 | 26字节       | 两个虚拟的行记录                 |
| **User Records**      | 用户记录         | 不确定       | 实际存储的行记录内容             |
| **Free Space**        | 空闲空间         | 不确定       | 页中尚未使用的空间               |
| **Page Directory**    | 页面目录         | 不确定       | 页中的某些记录的相对位置         |
| **File Trailer**      | 文件尾部         | 8字节        | 校验页是否完整                   |

表数据就是以行格式存储在 User Records 中。

### 页目录

## Explain

### 示例
```sql
EXPLAIN SELECT * FROM users WHERE username = 'zhangsan';
```

`EXPLAIN` 的输出如下：

```
+----+-------------+-------+------------+------+---------------+---------+---------+-------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key     | key_len | ref   | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+---------+---------+-------+------+----------+-------------+
|  1 | SIMPLE      | users | NULL       | ref  | idx_username  | idx_username | 102   | const |    1 |   100.00 | Using where |
+----+-------------+-------+------------+------+---------------+---------+---------+-------+------+----------+-------------+
```

- `id`：`1`，表示这个查询是一个简单查询。对于复杂的查询，如带有子查询或联合查询的，`id` 值可能会不同。
- `select_type`：`SIMPLE`，表示这是一个没有子查询的简单查询。
- `table`：`users`，查询的表是 `users`。
- `type`：`ref`，表示使用了索引扫描 *** 。
- `possible_keys`：`idx_username`，表示可能使用的索引是 `idx_username`。
- `key`：`idx_username`，实际使用的索引是 `idx_username`。
- `key_len`：`102`，表示索引键的长度是 102 字节。
- `ref`：`const`，表示查询条件是一个常量。
- `rows`：`1`，表示预计扫描 1 行。
- `filtered`：`100.00`，表示过滤条件通过的百分比是 100%。
- `Extra`：`Using where`，表示查询使用了 `WHERE` 条件过滤。

### select_type：`SELECT` 语句的类型，表示查询的类型。常见的类型有：
  - `SIMPLE`：简单查询，不包含子查询或联合查询。
  - `PRIMARY`：主查询，即最外层的查询。
  - `UNION`：`UNION` 操作的第二个或后续的查询。
  - `DEPENDENT UNION`：依赖于外部查询的 `UNION`。
  - `SUBQUERY`：子查询。
  - `DEPENDENT SUBQUERY`：依赖于外部查询的子查询。
  - `DERIVED`：派生表（临时表）。

### type：表访问方式，表示 MySQL 如何查找满足条件的行。访问方式的效率从高到低包括：
  - `system`：系统表，表中只有一行。
  - `const`：常量表，表中最多有一个匹配行。
  - `eq_ref`：唯一索引扫描，对于每个索引键值访问一个表中的一行。
  - `ref`：非唯一索引扫描，返回所有匹配的行。
  - `range`：索引范围扫描。
  - `index`：全索引扫描。
  - `ALL`：全表扫描。

### Extra：额外的信息，描述查询执行的详细情况。常见的值包括：
  - `Using index`：查询使用了覆盖索引。
  - `Using where`：查询使用了 `WHERE` 条件过滤。
  - `Using temporary`：查询使用了临时表。
  - `Using filesort`：查询使用了文件排序，表示需要额外的排序步骤。

## 分库分表
## 深度分页
## 冷热数据
## 数据库优化


## 参考
[深入理解 Mysql 索引底层原理](https://zhuanlan.zhihu.com/p/113917726)  
[next-key锁定范围](https://segmentfault.com/a/1190000040129107)  
[索引之道](https://juejin.cn/post/7161964571853815822)  
[MySQL 是怎样运行的：从根儿上理解 MySQL](https://relph1119.github.io/mysql-learning-notes/#/)
[两万字详解InnoDB的锁](https://juejin.cn/post/7094049650428084232)